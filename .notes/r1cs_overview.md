# Jolt R1CS Inputs and Constraints

This document lists all R1CS inputs and uniform constraints used in Jolt's RV32IM verification. There are a total of **28** uniform constraints. The information is sourced from `jolt-core/src/r1cs/inputs.rs` and `jolt-core/src/r1cs/constraints.rs`.

## R1CS Inputs

The following are the inputs to the R1CS constraint system. These are represented as multilinear polynomials over the trace of computation.
- **Committed** inputs are polynomials whose evaluations are committed to by the prover.
- **Virtual** inputs are polynomials derived from committed inputs or other sources, but are not committed to directly.

For RV64, register and memory values are 64-bit.

| Input Name | Nature | Type | Description |
|---|---|---|---|
| `PC` | Virtual | `u64` | Program Counter for the current instruction (bytecode address). |
| `UnexpandedPC` | Virtual | `u64` | Program Counter for the current instruction (unexpanded, raw RV address). |
| `Rd` | Virtual | `u5` | Destination register index. |
| `Imm` | Virtual | `i64` | Immediate value for the instruction. |
| `RamAddress` | Virtual | `u64` | Address for RAM access (load/store). |
| `Rs1Value` | Virtual | `u64` | Value of source register 1. |
| `Rs2Value` | Virtual | `u64` | Value of source register 2. |
| `RdWriteValue` | Virtual | `u64` | Value to be written to the destination register. |
| `RamReadValue` | Virtual | `u64` | Value read from RAM. |
| `RamWriteValue` | Virtual | `u64` | Value to be written to RAM. |
| `LeftInstructionInput` | Committed | `u64` | Left operand for an instruction. |
| `RightInstructionInput` | Committed | `u64` | Right operand for an instruction. |
| `LeftLookupOperand` | Virtual | `u64` | Left operand for a lookup query. |
| `RightLookupOperand`| Virtual | `u128` | Right operand for a lookup query. |
| `Product` | Committed | `u128` | Product of `LeftInstructionInput` and `RightInstructionInput`. |
| `WriteLookupOutputToRD` | Committed | `bool` | Flag, `Rd != 0 && WriteLookupOutputToRD_flag`. |
| `WritePCtoRD` | Committed | `bool` | Flag, `Rd != 0 && Jump_flag`. |
| `ShouldBranch` | Committed | `bool` | Flag, `Branch_flag && LookupOutput != 0`. |
| `ShouldJump` | Committed | `bool`| Flag, `Jump_flag && !NextIsNoop`. |
| `NextUnexpandedPC` | Virtual | `u64` | The program counter for the next instruction. |
| `NextPC` | Virtual | `u64` | The bytecode address for the next instruction. |
| `LookupOutput` | Virtual | `u64` | The output of a lookup operation. |
| `NextIsNoop`| Virtual | `bool` | Flag indicating if the next instruction is a NoOp. |
| `CompressedDoNotUpdateUnexpPC` | Committed | `bool` | Flag `IsCompressed && DoNotUpdateUnexpandedPC`. |
| `OpFlags(CircuitFlags)` | Virtual | `bool` | A set of boolean flags (`0` or `1`) indicating instruction properties. |

The `OpFlags` include:
- `LeftOperandIsRs1Value`
- `RightOperandIsRs2Value`
- `LeftOperandIsPC`
- `RightOperandIsImm`
- `AddOperands`
- `SubtractOperands`
- `MultiplyOperands`
- `Load`
- `Store`
- `Jump`
- `Branch`
- `WriteLookupOutputToRD`
- `InlineSequenceInstruction`
- `Assert`
- `DoNotUpdateUnexpandedPC`
- `Advice`
- `IsNoop`
- `IsCompressed`

## Exhaustive RV64 Constraint-by-Constraint Analysis

This section provides a complete, one-by-one analysis of all **28 uniform constraints** for the RV64 transition. We examine the `Az`, `Bz`, and `Cz` wires generated by the `R1CSBuilder` for each constraint to determine if they meet the following criteria for Small Value Optimization (SVO):

- **`Az`**: Must be "small", preferably a boolean flag. A value up to 64 bits is considered "bad".
- **`Bz`**: Must be at most 64 bits. Any value that can exceed this (e.g., approach 128 bits) is "bad".
- **`Cz`**: Must be zero or "small" (at most 64 bits). Any value that can exceed this is "bad".

A constraint is flagged as **BAD** if it violates any of these conditions.

---

### Operand Selection (Constraints 1-6)

1.  **Constraint**: `if LeftOperandIsRs1Value { LeftInstructionInput == Rs1Value }`
    -   **`Az`**: `OpFlag` (boolean) → **OK**.
    -   **`Bz`**: `u64 - u64` (at most 64 bits) → **OK**.
    -   **`Cz`**: `0` → **OK**.
    -   **Verdict**: **OK**.

2.  **Constraint**: `if LeftOperandIsPC { LeftInstructionInput == UnexpandedPC }`
    -   **`Az`**: `OpFlag` (boolean) → **OK**.
    -   **`Bz`**: `u64 - u64` (at most 64 bits) → **OK**.
    -   **`Cz`**: `0` → **OK**.
    -   **Verdict**: **OK**.

3.  **Constraint**: `if !(LeftOperandIsRs1Value || LeftOperandIsPC) { LeftInstructionInput == 0 }`
    -   **`Az`**: `1 - Flag - Flag` (boolean) → **OK**.
    -   **`Bz`**: `u64` (64 bits) → **OK**.
    -   **`Cz`**: `0` → **OK**.
    -   **Verdict**: **OK**.

4.  **Constraint**: `if RightOperandIsRs2Value { RightInstructionInput == Rs2Value }`
    -   **`Az`**: `OpFlag` (boolean) → **OK**.
    -   **`Bz`**: `u64 - u64` (at most 64 bits) → **OK**.
    -   **`Cz`**: `0` → **OK**.
    -   **Verdict**: **OK**.

5.  **Constraint**: `if RightOperandIsImm { RightInstructionInput == Imm }`
    -   **`Az`**: `OpFlag` (boolean) → **OK**.
    -   **`Bz`**: `u64 - i64` (at most 64 bits) → **OK**.
    -   **`Cz`**: `0` → **OK**.
    -   **Verdict**: **OK**.

6.  **Constraint**: `if !(RightOperandIsRs2Value || RightOperandIsImm) { RightInstructionInput == 0 }`
    -   **`Az`**: `1 - Flag - Flag` (boolean) → **OK**.
    -   **`Bz`**: `u64` (64 bits) → **OK**.
    -   **`Cz`**: `0` → **OK**.
    -   **Verdict**: **OK**.

---

### Memory Operations (Constraints 7-10)

7.  **Constraint**: `if (Load || Store) { RamAddress == Rs1Value + Imm } else { RamAddress == 0 }`
    -   This is a `constrain_if_else`, resulting in `(condition) * (if_val - else_val) = (target - else_val)`.
    -   **`Az`**: `Load_Flag + Store_Flag` (boolean) → **OK**.
    -   **`Bz`**: `(Rs1Value + Imm) - 0` (`u64 + i64`, at most 65 bits) → **OK**.
    -   **`Cz`**: `RamAddress - 0` (`u64`, 64 bits) → **OK**.
    -   **Verdict**: **OK**.

8.  **Constraint**: `if Load { RamReadValue == RamWriteValue }`
    -   **`Az`**: `OpFlag` (boolean) → **OK**.
    -   **`Bz`**: `u64 - u64` (at most 64 bits) → **OK**.
    -   **`Cz`**: `0` → **OK**.
    -   **Verdict**: **OK**.

9.  **Constraint**: `if Load { RamReadValue == RdWriteValue }`
    -   **`Az`**: `OpFlag` (boolean) → **OK**.
    -   **`Bz`**: `u64 - u64` (at most 64 bits) → **OK**.
    -   **`Cz`**: `0` → **OK**.
    -   **Verdict**: **OK**.

10. **Constraint**: `if Store { Rs2Value == RamWriteValue }`
    -   **`Az`**: `OpFlag` (boolean) → **OK**.
    -   **`Bz`**: `u64 - u64` (at most 64 bits) → **OK**.
    -   **`Cz`**: `0` → **OK**.
    -   **Verdict**: **OK**.

---

### Arithmetic & Lookups (Constraints 11-17)

11. **Constraint**: `if AddOperands || SubtractOperands || MultiplyOperands { LeftLookupOperand == 0 } else { LeftLookupOperand == LeftInstructionInput }`
    -   **`Az`**: `Flag + Flag + Flag` (boolean) → **OK**.
    -   **`Bz`**: `0 - LeftInstructionInput` (`-u64`, 64 bits) → **OK**.
    -   **`Cz`**: `LeftLookupOperand - LeftInstructionInput` (`u64 - u64`, at most 64 bits) → **OK**.
    -   **Verdict**: **OK**.

12. **Constraint**: `if AddOperands { RightLookupOperand == LeftInstructionInput + RightInstructionInput }`
    -   **`Az`**: `OpFlag` (boolean) → **OK**.
    -   **`Bz`**: `RightLookupOperand - (u64 + u64)`. `RightLookupOperand` is `u128`, so `Bz` can be `~u128`. → **BAD (exceeds 64 bits)**.
    -   **`Cz`**: `0` → **OK**.
    -   **Verdict**: **BAD**.

13. **Constraint**: `if SubtractOperands { RightLookupOperand == LeftInstructionInput - RightInstructionInput + 2^64 }`
    -   **`Az`**: `OpFlag` (boolean) → **OK**.
    -   **`Bz`**: `RightLookupOperand - (u64 - u64 + 2^64)`. `RightLookupOperand` is `u128`, so `Bz` can be `~u128`. → **BAD (exceeds 64 bits)**.
    -   **`Cz`**: `0` → **OK**.
    -   **Verdict**: **BAD**.

14. **Constraint**: `constrain_prod(RightInstructionInput, LeftInstructionInput, Product)`
    -   **`Az`**: `RightInstructionInput` (`u64`) → **OK**.
    -   **`Bz`**: `LeftInstructionInput` (`u64`) → **OK**.
    -   **`Cz`**: `Product` (`u128`) → **BAD (exceeds 64 bits)**.
    -   **Verdict**: **BAD**. (Moved to `may_overflow_constraints`).

15. **Constraint**: `if MultiplyOperands { RightLookupOperand == Product }`
    -   **`Az`**: `OpFlag` (boolean) → **OK**.
    -   **`Bz`**: `RightLookupOperand - Product` (`u128 - u128`). Can be `~u128`. → **BAD (exceeds 64 bits)**.
    -   **`Cz`**: `0` → **OK**.
    -   **Verdict**: **BAD**. (Moved to `may_overflow_constraints`).

16. **Constraint**: `if !(AddOperands || ... || Advice) { RightLookupOperand == RightInstructionInput }`
    -   **`Az`**: `1 - Flag - Flag - Flag - Flag` (boolean) → **OK**.
    -   **`Bz`**: `RightLookupOperand - RightInstructionInput` (`u128 - u64`). Can be `~u128`. → **BAD (exceeds 64 bits)**.
    -   **`Cz`**: `0` → **OK**.
    -   **Verdict**: **BAD**.

17. **Constraint**: `if Assert { LookupOutput == 1 }`
    -   **`Az`**: `OpFlag` (boolean) → **OK**.
    -   **`Bz`**: `u64 - 1` (at most 64 bits) → **OK**.
    -   **`Cz`**: `0` → **OK**.
    -   **Verdict**: **OK**.

---

### Register & PC Updates (Constraints 18-28)

18. **Constraint**: `constrain_prod(OpFlag(WriteLookupOutputToRD), Rd, WriteLookupOutputToRD)`
    -   **`Az`**: `OpFlag` (boolean) → **OK**.
    -   **`Bz`**: `Rd` (`u5`) → **OK**.
    -   **`Cz`**: `WriteLookupOutputToRD` (committed, max `u5`) → **OK**.
    -   **Verdict**: **OK**.

19. **Constraint**: `if WriteLookupOutputToRD { RdWriteValue == LookupOutput }`
    -   **`Az`**: `WriteLookupOutputToRD` (max `u5`) → **OK**.
    -   **`Bz`**: `u64 - u64` (at most 64 bits) → **OK**.
    -   **`Cz`**: `0` → **OK**.
    -   **Verdict**: **OK**.

20. **Constraint**: `constrain_prod(OpFlag(Jump), Rd, WritePCtoRD)`
    -   **`Az`**: `OpFlag` (boolean) → **OK**.
    -   **`Bz`**: `Rd` (`u5`) → **OK**.
    -   **`Cz`**: `WritePCtoRD` (committed, max `u5`) → **OK**.
    -   **Verdict**: **OK**.

21. **Constraint**: `if WritePCtoRD { RdWriteValue == UnexpandedPC + 4 - 2 * IsCompressed }`
    -   **`Az`**: `WritePCtoRD` (max `u5`) → **OK**.
    -   **`Bz`**: `u64 - (u64 + const)` (at most 64 bits) → **OK**.
    -   **`Cz`**: `0` → **OK**.
    -   **Verdict**: **OK**.

22. **Constraint**: `constrain_prod(OpFlag(Jump), 1 - NextIsNoop, ShouldJump)`
    -   **`Az`**: `OpFlag` (boolean) → **OK**.
    -   **`Bz`**: `1 - NextIsNoop` (boolean) → **OK**.
    -   **`Cz`**: `ShouldJump` (committed, boolean) → **OK**.
    -   **Verdict**: **OK**.

23. **Constraint**: `if ShouldJump { NextUnexpandedPC == LookupOutput }`
    -   **`Az`**: `ShouldJump` (boolean) → **OK**.
    -   **`Bz`**: `u64 - u64` (at most 64 bits) → **OK**.
    -   **`Cz`**: `0` → **OK**.
    -   **Verdict**: **OK**.

24. **Constraint**: `constrain_prod(Branch_flag, LookupOutput, ShouldBranch)`
    -   **`Az`**: `Branch_flag` (boolean) → **OK**.
    -   **`Bz`**: `LookupOutput` (`u64`) → **OK**.
    -   **`Cz`**: `ShouldBranch` (committed, max `u64`) → **OK**.
    -   **Verdict**: **OK**.

25. **Constraint**: `if ShouldBranch { NextUnexpandedPC == UnexpandedPC + Imm }`
    -   **`Az`**: `ShouldBranch` (max `u64`) → **BAD (not a small flag)**.
    -   **`Bz`**: `u64 - (u64 + i64)` (at most 64 bits) → **OK**.
    -   **`Cz`**: `0` → **OK**.
    -   **Verdict**: **BAD**.

26. **Constraint**: `constrain_prod(IsCompressed, DoNotUpdateUnexpandedPC, CompressedDoNotUpdateUnexpPC)`
    -   **`Az`**: `OpFlag` (boolean) → **OK**.
    -   **`Bz`**: `OpFlag` (boolean) → **OK**.
    -   **`Cz`**: `CompressedDoNotUpdateUnexpPC` (committed, boolean) → **OK**.
    -   **Verdict**: **OK**.

27. **Constraint**: `if !(ShouldBranch || Jump) { NextUnexpandedPC == UnexpandedPC + 4 - ... }`
    -   **`Az`**: `1 - ShouldBranch - Jump_flag`. Since `ShouldBranch` can be `u64`, `Az` can be `~u64`. → **BAD (not a small flag)**.
    -   **`Bz`**: `u64 - (u64 + const)` (at most 64 bits) → **OK**.
    -   **`Cz`**: `0` → **OK**.
    -   **Verdict**: **BAD**.

28. **Constraint**: `if InlineSequenceInstruction { NextPC == PC + 1 }`
    -   **`Az`**: `OpFlag` (boolean) → **OK**.
    -   **`Bz`**: `u64 - (u64 + 1)` (constant) → **OK**.
    -   **`Cz`**: `0` → **OK**.
    -   **Verdict**: **OK**.

---

## Summary of "Bad" Constraints

Based on the SVO criteria, there are **7 bad constraints** that require special handling:

1.  **Constraint #12 (Add)**: `Bz` can exceed 64 bits.
2.  **Constraint #13 (Subtract)**: `Bz` can exceed 64 bits.
3.  **Constraint #14 (Product)**: `Cz` is `u128`.
4.  **Constraint #15 (Multiply Result)**: `Bz` can exceed 64 bits.
5.  **Constraint #16 (Default Lookup)**: `Bz` can exceed 64 bits.
6.  **Constraint #25 (Branch PC Update)**: `Az` can be a 64-bit value.
7.  **Constraint #27 (Default PC Update)**: `Az` can be a 64-bit value.

This analysis is critical for designing the arithmetization and ensuring that the Small Value Optimization protocol can be applied soundly without encountering overflows.
