//! Trace writer utilities for inline instructions
//!
//! This module provides functionality to write inline instruction traces to text files.
//!
//! ## Important Note on Generated Trace Files
//!
//! The trace files generated by this module use either default values or user-provided input
//! values for `SequenceInputs` (address, registers, etc.). However, during actual runtime
//! execution, these values will vary according to the specific bytecode being executed.
//!
//! When using a statically generated trace file to obtain the trace of an inline instruction,
//! you must update the `SequenceInputs` values for each call to the inline assembly to match
//! the actual runtime values from your program.
//!
//! Failure to update these values will result in incorrect trace execution.

use std::fs::{File, OpenOptions};
use std::io::{self, Write};
use std::path::Path;
use tracer::emulator::cpu::Xlen;
use tracer::instruction::RV32IMInstruction;

// Default constants for SequenceInputs
pub const DEFAULT_RAM_START_ADDRESS: u64 = 0x80000000;
pub const DEFAULT_XLEN: Xlen = Xlen::Bit64;
pub const DEFAULT_RS1: u8 = 10;
pub const DEFAULT_RS2: u8 = 11;
pub const DEFAULT_RS3: u8 = 12;
pub const DEFAULT_IS_COMPRESSED: bool = false;

/// Descriptor for an inline instruction containing its identifying information
#[derive(Debug, Clone)]
pub struct InlineDescriptor {
    /// Human-readable name of the inline instruction
    pub name: String,
    pub opcode: u32,
    pub funct3: u32,
    pub funct7: u32,
}

impl InlineDescriptor {
    pub fn new(name: String, opcode: u32, funct3: u32, funct7: u32) -> Self {
        Self {
            name,
            opcode,
            funct3,
            funct7,
        }
    }
}

/// Input parameters for instruction sequence generation
#[derive(Debug, Clone)]
pub struct SequenceInputs {
    /// Memory address of the instruction
    pub address: u64,
    /// Whether the instruction is compressed
    pub is_compressed: bool,
    /// CPU architecture width (32 or 64)
    pub xlen: Xlen,
    pub rs1: u8,
    pub rs2: u8,
    pub rs3: u8,
}

impl SequenceInputs {
    pub fn new(address: u64, is_compressed: bool, xlen: Xlen, rs1: u8, rs2: u8, rs3: u8) -> Self {
        Self {
            address,
            is_compressed,
            xlen,
            rs1,
            rs2,
            rs3,
        }
    }
}

impl Default for SequenceInputs {
    fn default() -> Self {
        Self {
            address: DEFAULT_RAM_START_ADDRESS,
            is_compressed: DEFAULT_IS_COMPRESSED,
            xlen: DEFAULT_XLEN,
            rs1: DEFAULT_RS1,
            rs2: DEFAULT_RS2,
            rs3: DEFAULT_RS3,
        }
    }
}

/// Writes inline instruction trace to a file
///
/// # Format
///
/// The file format is:
/// - Empty line (if append=true)
/// - Line 1: inline_name, opcode, funct3, funct7
/// - Line 2: address, is_compressed, xlen, rs1, rs2, rs3
/// - Lines 3+: Each RV32IMInstruction formatted with Debug (`:?`)
///
/// # Arguments
///
/// * `file_path` - Path to the output file
/// * `inline_info` - Descriptor containing inline instruction information
/// * `sequence_inputs` - Input parameters for the instruction sequence
/// * `instructions` - Slice of RV32IMInstruction to write
/// * `append` - If true, append to existing file; if false, overwrite
pub fn write_inline_trace(
    file_path: impl AsRef<Path>,
    inline_info: &InlineDescriptor,
    sequence_inputs: &SequenceInputs,
    instructions: &[RV32IMInstruction],
    append: bool,
) -> io::Result<()> {
    let mut file = if append {
        OpenOptions::new()
            .create(true)
            .append(true)
            .open(file_path)?
    } else {
        File::create(file_path)?
    };

    if append {
        writeln!(file)?;
    }

    writeln!(
        file,
        "{}, {:#04x}, {}, {}",
        inline_info.name, inline_info.opcode, inline_info.funct3, inline_info.funct7
    )?;

    let xlen = match sequence_inputs.xlen {
        Xlen::Bit32 => "32",
        Xlen::Bit64 => "64",
    };

    writeln!(
        file,
        "{:#010x}, {}, {}, {}, {}, {}",
        sequence_inputs.address,
        sequence_inputs.is_compressed,
        xlen,
        sequence_inputs.rs1,
        sequence_inputs.rs2,
        sequence_inputs.rs3
    )?;

    for instruction in instructions {
        writeln!(file, "{instruction:?}")?;
    }

    Ok(())
}
