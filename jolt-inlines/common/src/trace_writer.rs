//! Trace writer utilities for inline instructions
//! This module provides functionality to write inline instruction traces to `.joltinline` files.
//!
//! The trace files generated by this module use placeholder values for instruction addresses and registers.
//! During actual runtime execution, these values will vary according to the specific bytecode being executed
//! and should be replaced with actual runtime values.

use std::fs::{File, OpenOptions};
use std::io::{self, Write};
use std::path::Path;
use tracer::emulator::cpu::Xlen;
use tracer::instruction::RV32IMInstruction;

pub const DEFAULT_RAM_START_ADDRESS: u64 = 0x80000000;
pub const DEFAULT_XLEN: Xlen = Xlen::Bit64;
pub const DEFAULT_RS1: u8 = 10;
pub const DEFAULT_RS2: u8 = 11;
pub const DEFAULT_RS3: u8 = 12;
pub const DEFAULT_IS_COMPRESSED: bool = false;

/// Descriptor for an inline instruction containing its identifying information
#[derive(Debug, Clone)]
pub struct InlineDescriptor {
    /// Human-readable name of the inline instruction
    pub name: String,
    pub opcode: u32,
    pub funct3: u32,
    pub funct7: u32,
}

impl InlineDescriptor {
    pub fn new(name: String, opcode: u32, funct3: u32, funct7: u32) -> Self {
        Self {
            name,
            opcode,
            funct3,
            funct7,
        }
    }
}

/// Input parameters for instruction sequence generation
#[derive(Debug, Clone)]
pub struct SequenceInputs {
    /// Memory address of the instruction
    pub address: u64,
    /// Whether the instruction is compressed
    pub is_compressed: bool,
    /// CPU architecture width (32 or 64)
    pub xlen: Xlen,
    pub rs1: u8,
    pub rs2: u8,
    pub rs3: u8,
}

impl SequenceInputs {
    pub fn new(address: u64, is_compressed: bool, xlen: Xlen, rs1: u8, rs2: u8, rs3: u8) -> Self {
        Self {
            address,
            is_compressed,
            xlen,
            rs1,
            rs2,
            rs3,
        }
    }
}

impl Default for SequenceInputs {
    fn default() -> Self {
        Self {
            address: DEFAULT_RAM_START_ADDRESS,
            is_compressed: DEFAULT_IS_COMPRESSED,
            xlen: DEFAULT_XLEN,
            rs1: DEFAULT_RS1,
            rs2: DEFAULT_RS2,
            rs3: DEFAULT_RS3,
        }
    }
}

/// Writes inline instruction trace to a file
///
/// # Format
///
/// The file format is:
/// - Empty line (if append=true)
/// - Line 1: inline_name, opcode, funct3, funct7
/// - Line 2: address, is_compressed, xlen, rs1, rs2, rs3
/// - Lines 3+: Each RV32IMInstruction, using placeholders instead of address, rs1, rs2, and rs3
///
/// # Arguments
///
/// * `file_path` - Path to the output file
/// * `inline_info` - Descriptor containing inline instruction information
/// * `sequence_inputs` - Input parameters for the instruction sequence
/// * `instructions` - Slice of RV32IMInstruction to write
/// * `append` - If true, append to existing file; if false, overwrite
pub fn write_inline_trace(
    file_path: impl AsRef<Path>,
    inline_info: &InlineDescriptor,
    sequence_inputs: &SequenceInputs,
    instructions: &[RV32IMInstruction],
    append: bool,
) -> io::Result<()> {
    let mut file = if append {
        OpenOptions::new()
            .create(true)
            .append(true)
            .open(file_path)?
    } else {
        File::create(file_path)?
    };

    if append {
        writeln!(file)?;
    }

    writeln!(
        file,
        "name: {}, opcode: {:#04x}, funct3: {}, funct7: {}",
        inline_info.name, inline_info.opcode, inline_info.funct3, inline_info.funct7
    )?;

    let xlen = match sequence_inputs.xlen {
        Xlen::Bit32 => "32",
        Xlen::Bit64 => "64",
    };

    writeln!(
        file,
        "address: $ADDR, is_compressed: {}, xlen: {}, rs1: $RS1, rs2: $RS2, rs3: $RS3",
        sequence_inputs.is_compressed, xlen,
    )?;

    for instruction in instructions {
        let formatted = format_instruction_with_placeholders(instruction, sequence_inputs);
        writeln!(file, "{formatted}")?;
    }

    Ok(())
}

/// Formats an instruction with placeholders for address and registers matching sequence inputs
///
/// Replaces:
/// - Address with $ADDR
/// - Registers matching sequence_inputs.rs1/rs2/rs3 with $RS1/$RS2/$RS3
/// - Keeps other registers with their actual values
fn format_instruction_with_placeholders(
    instruction: &RV32IMInstruction,
    sequence_inputs: &SequenceInputs,
) -> String {
    let mut formatted = format!("{instruction:?}");
    let normalized_instr = instruction.normalize();

    // Replace address with placeholder (address is always in hex format)
    let address_pattern = format!("address: {:#x}", normalized_instr.address);
    formatted = formatted.replace(&address_pattern, "address: $ADDR");

    // Create a mapping of values to their placeholders
    let reg_value_to_placeholder = [
        (sequence_inputs.rs1, "$RS1"),
        (sequence_inputs.rs2, "$RS2"),
        (sequence_inputs.rs3, "$RS3"),
    ];

    for (register, value) in [
        ("rs1", normalized_instr.operands.rs1),
        ("rs2", normalized_instr.operands.rs2),
    ] {
        for (input_value, placeholder) in &reg_value_to_placeholder {
            if value == *input_value {
                // Replace register value (always in decimal format)
                let pattern = format!("{register}: {value}");
                formatted = formatted.replace(&pattern, &format!("{register}: {placeholder}"));
                break;
            }
        }
    }

    formatted
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use std::io::{BufRead, BufReader};
    use std::path::Path;

    /// Test that verifies the trace writer correctly generates a trace file with placeholders
    /// and that the placeholders can be replaced to match the original instructions.
    ///
    /// This test uses the keccak256 inline instruction as an example.
    #[test]
    fn test_keccak256_trace_file_matches_generated() {
        use jolt_inlines_keccak256::trace_generator::keccak256_inline_sequence_builder;

        // Generate the instructions
        let generated_instructions = keccak256_inline_sequence_builder(
            DEFAULT_RAM_START_ADDRESS,
            false,
            DEFAULT_XLEN,
            DEFAULT_RS1,
            DEFAULT_RS2,
            DEFAULT_RS3,
        );

        // Path to the keccak256 trace file
        let trace_file_path = Path::new("keccak256_trace.joltinline");

        // Ensure the file is deleted at the end of the test
        let _cleanup = FileCleanup(trace_file_path);

        // Now read and validate the file
        let file = fs::File::open(trace_file_path).expect("Failed to open test trace file");
        let reader = BufReader::new(file);
        let mut lines = reader.lines();

        // Read and validate header (line 1)
        let header = lines
            .next()
            .expect("Missing header line")
            .expect("Failed to read header");
        assert!(
            header.contains("KECCAK256_INLINE"),
            "Expected KECCAK256_INLINE in header, got: {header}"
        );

        // Read and validate sequence inputs (line 2)
        let inputs_line = lines
            .next()
            .expect("Missing inputs line")
            .expect("Failed to read inputs");
        assert!(inputs_line.contains("address: $ADDR"));

        // Now compare each instruction line by line
        for (i, generated_instr) in generated_instructions.iter().enumerate() {
            // Read next line from trace file
            let mut trace_line = lines.next().unwrap().unwrap();
            trace_line = trace_line.replace(
                "address: $ADDR",
                &format!("address: {DEFAULT_RAM_START_ADDRESS:#x}"),
            );
            trace_line = trace_line.replace("$RS1", &format!("{DEFAULT_RS1}"));
            trace_line = trace_line.replace("$RS2", &format!("{DEFAULT_RS2}"));
            trace_line = trace_line.replace("$RS3", &format!("{DEFAULT_RS3}"));

            // Compare
            assert_eq!(
                format!("{generated_instr:?}"),
                trace_line,
                "Instruction mismatch at line {} (index {}). Generated: {}, Trace: {}",
                i + 3,
                i,
                format!("{:?}", generated_instr),
                trace_line
            );
        }

        // Check if there are any extra lines in the trace file
        assert!(
            lines.next().is_none(),
            "Trace file has extra lines after all instructions"
        );
    }

    /// Helper struct to ensure test file cleanup on drop
    struct FileCleanup<'a>(&'a Path);

    impl<'a> Drop for FileCleanup<'a> {
        fn drop(&mut self) {
            if self.0.exists() {
                let _ = fs::remove_file(self.0);
            }
        }
    }
}
