//! Trace writer utilities for inline instructions
//! This module provides functionality to write inline instruction traces to `.joltinline` files.
//!
//! The trace files generated by this module use placeholder values for instruction addresses and registers.
//! During actual runtime execution, these values will vary according to the specific bytecode being executed
//! and should be replaced with actual runtime values.

use crate::emulator::cpu::Xlen;
use crate::instruction::RV32IMInstruction;
use std::fs::{File, OpenOptions};
use std::io::{self, Write};
use std::path::Path;

pub const DEFAULT_RAM_START_ADDRESS: u64 = 0x80000000;
pub const DEFAULT_XLEN: Xlen = Xlen::Bit64;
pub const DEFAULT_RS1: u8 = 10;
pub const DEFAULT_RS2: u8 = 11;
pub const DEFAULT_RS3: u8 = 12;
pub const DEFAULT_IS_COMPRESSED: bool = false;

/// Descriptor for an inline instruction containing its identifying information
#[derive(Debug, Clone)]
pub struct InlineDescriptor {
    /// Human-readable name of the inline instruction
    pub name: String,
    pub opcode: u32,
    pub funct3: u32,
    pub funct7: u32,
}

impl InlineDescriptor {
    pub fn new(name: String, opcode: u32, funct3: u32, funct7: u32) -> Self {
        Self {
            name,
            opcode,
            funct3,
            funct7,
        }
    }
}

/// Input parameters for instruction sequence generation
#[derive(Debug, Clone)]
pub struct SequenceInputs {
    /// Memory address of the instruction
    pub address: u64,
    /// Whether the instruction is compressed
    pub is_compressed: bool,
    /// CPU architecture width (32 or 64)
    pub xlen: Xlen,
    pub rs1: u8,
    pub rs2: u8,
    pub rs3: u8,
}

impl SequenceInputs {
    pub fn new(address: u64, is_compressed: bool, xlen: Xlen, rs1: u8, rs2: u8, rs3: u8) -> Self {
        Self {
            address,
            is_compressed,
            xlen,
            rs1,
            rs2,
            rs3,
        }
    }
}

impl Default for SequenceInputs {
    fn default() -> Self {
        Self {
            address: DEFAULT_RAM_START_ADDRESS,
            is_compressed: DEFAULT_IS_COMPRESSED,
            xlen: DEFAULT_XLEN,
            rs1: DEFAULT_RS1,
            rs2: DEFAULT_RS2,
            rs3: DEFAULT_RS3,
        }
    }
}

pub enum AppendMode {
    Append,
    Overwrite,
}

/// Writes inline instruction trace to a file
///
/// # Format
///
/// The file format is:
/// - Empty line (if append=true)
/// - Line 1: inline_name, opcode, funct3, funct7
/// - Line 2: address, is_compressed, xlen, rs1, rs2, rs3
/// - Lines 3+: Each RV32IMInstruction, using placeholders instead of address, rs1, rs2, and rs3
///
/// # Arguments
///
/// * `file_path` - Path to the output file
/// * `inline_info` - Descriptor containing inline instruction information
/// * `sequence_inputs` - Input parameters for the instruction sequence
/// * `instructions` - Slice of RV32IMInstruction to write
/// * `append` - If true, append to existing file; if false, overwrite
pub fn write_inline_trace(
    file_path: impl AsRef<Path>,
    inline_info: &InlineDescriptor,
    sequence_inputs: &SequenceInputs,
    instructions: &[RV32IMInstruction],
    append: AppendMode,
) -> io::Result<()> {
    let mut file = match append {
        AppendMode::Append => OpenOptions::new()
            .create(true)
            .append(true)
            .open(file_path)?,
        AppendMode::Overwrite => File::create(file_path)?,
    };

    if matches!(append, AppendMode::Append) {
        writeln!(file)?;
    }

    writeln!(
        file,
        "name: {}, opcode: {:#04x}, funct3: {}, funct7: {}",
        inline_info.name, inline_info.opcode, inline_info.funct3, inline_info.funct7
    )?;

    let xlen = match sequence_inputs.xlen {
        Xlen::Bit32 => "32",
        Xlen::Bit64 => "64",
    };

    writeln!(
        file,
        "address: $ADDR, is_compressed: {}, xlen: {}, rs1: $RS1, rs2: $RS2, rs3: $RS3",
        sequence_inputs.is_compressed, xlen,
    )?;

    for instruction in instructions {
        let formatted = format_instruction_with_placeholders(instruction, sequence_inputs);
        writeln!(file, "{formatted}")?;
    }

    Ok(())
}

/// Formats an instruction with placeholders for address and registers matching sequence inputs
///
/// Replaces:
/// - Address with $ADDR
/// - Registers matching sequence_inputs.rs1/rs2/rs3 with $RS1/$RS2/$RS3
/// - Keeps other registers with their actual values
fn format_instruction_with_placeholders(
    instruction: &RV32IMInstruction,
    sequence_inputs: &SequenceInputs,
) -> String {
    let mut formatted = format!("{instruction:?}");
    let normalized_instr = instruction.normalize();

    // Replace address with placeholder (address is always in hex format)
    let address_pattern = format!("address: {:#x}", normalized_instr.address);
    formatted = formatted.replace(&address_pattern, "address: $ADDR");

    // Create a mapping of values to their placeholders
    let reg_value_to_placeholder = [
        (sequence_inputs.rs1, "$RS1"),
        (sequence_inputs.rs2, "$RS2"),
        (sequence_inputs.rs3, "$RS3"),
    ];

    for (register, value) in [
        ("rs1", normalized_instr.operands.rs1),
        ("rs2", normalized_instr.operands.rs2),
    ] {
        for (input_value, placeholder) in &reg_value_to_placeholder {
            if value == *input_value {
                // Replace register value (always in decimal format)
                let pattern = format!("{register}: {value}");
                formatted = formatted.replace(&pattern, &format!("{register}: {placeholder}"));
                break;
            }
        }
    }

    formatted
}
