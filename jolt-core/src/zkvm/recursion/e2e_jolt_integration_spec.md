Here describes the requirements for integrating the snark composition / recursion snark into the main prover.rs and verifier.rs:

first of all, read the spec.md to understand the purpose for this SNARK and how it is contributing to the proof system to make the verifier cheaper.

Now, Essentially what we need to do is the following:

1. After generating the main dory proof for jolt, we need to use the RecursionExt to do witness gen for dory (should use the same commitment and proof as stored in JoltProof)
2. the JoltProof should also hold a RecursionProof and the hints generated by the witness generated
3. We will feed the witness into the recursion prover with hyrax in order to generate the recursion proof
4. 1,2,3 this will execute stages 1,2,3 of the recursion snark and it will also execute the hyrax opening proof
5. That should be all on the prover side
6. the verifier side should then be able to verify the dory proof **with the hints** (this is the whole point of doing this to make this step cheaper), and it should use all the normal data (if any other data is needed by verifier not accounted for so far then point it out and we wil come up with a solution, either by having verifier compute the pre processing or adding it to shared pre processing etc)
7. Verifier will then also verify the recursion proof (stages 1-3 and hyrax)

If at any point you are unsure about the flow or how some step should work or propogate, ask for clarification. Do not make any assumptions. I will work with you closely to get it right
Simplicity is best but do not cheat or use placeholder vlaues or anything temp or "for now" -- we have all the tools and infra to execute this e2e.
