//! Unified prover for the two-stage recursion SNARK protocol
//!
//! This module provides a high-level prover that orchestrates:
//! - Stage 1: Constraint sumchecks (GT exp, GT mul, G1 scalar mul)
//! - Stage 2: Virtualization sumcheck
//!
//! The prover returns a proof and opening accumulator for PCS verification.

use crate::{
    field::JoltField,
    poly::{
        commitment::{
            commitment_scheme::{CommitmentScheme, RecursionExt},
            dory::{
                wrappers::ArkDoryProof, ArkworksVerifierSetup,
                DoryCommitmentScheme,
            },
        },
        dense_mlpoly::DensePolynomial,
        multilinear_polynomial::MultilinearPolynomial,
        opening_proof::{ProverOpeningAccumulator, Openings},
    },
    transcripts::Transcript,
    zkvm::{
        witness::CommittedPolynomial,
        recursion::witness::{DoryRecursionWitness, G1ScalarMulWitness},
    },
};
use ark_bn254::{Fq, Fr};
use ark_ff::{One, Zero};
use dory::{backends::arkworks::ArkGT};
use std::collections::HashMap;

use super::{
    constraints_sys::ConstraintSystem,
    stage1::{
        g1_scalar_mul::{G1ScalarMulParams, G1ScalarMulProver},
        gt_mul::{GtMulParams, GtMulProver},
        square_and_multiply::{SquareAndMultiplyParams, SquareAndMultiplyProver},
    },
    stage2::virtualization::{
        RecursionVirtualizationParams, RecursionVirtualizationProver,
    },
};
use crate::subprotocols::{
    sumcheck::BatchedSumcheck,
    sumcheck_prover::SumcheckInstanceProver,
};

/// Proof generated by the recursion SNARK
#[derive(Clone)]
pub struct RecursionProof<F: JoltField, T: Transcript, PCS: CommitmentScheme<Field = F>> {
    /// Stage 1 constraint sumcheck proof
    pub stage1_proof: crate::subprotocols::sumcheck::SumcheckInstanceProof<F, T>,
    /// Stage 2 virtualization sumcheck proof
    pub stage2_proof: crate::subprotocols::sumcheck::SumcheckInstanceProof<F, T>,
    /// PCS opening proof for the constraint matrix
    pub opening_proof: PCS::Proof,
    /// Gamma value used for batching constraints
    pub gamma: F,
    /// Delta value used for batching within constraints
    pub delta: F,
    /// Opening claims for virtual polynomials
    pub opening_claims: Openings<F>,
}

/// Type alias for readability
type BatchedSumcheckProof<F> = crate::subprotocols::sumcheck::SumcheckInstanceProof<F, crate::transcripts::Blake2bTranscript>;

/// Unified prover for the recursion SNARK
pub struct RecursionProver<F: JoltField = Fq> {
    /// The constraint system containing all constraints and witness data
    pub constraint_system: ConstraintSystem,
    /// Gamma value for batching across constraints
    pub gamma: F,
    /// Delta value for batching within constraints
    pub delta: F,
}

impl RecursionProver<Fq> {
    /// Create a new recursion prover by generating witnesses from a Dory proof
    pub fn new_from_dory_proof<T: Transcript>(
        dory_proof: &ArkDoryProof,
        verifier_setup: &ArkworksVerifierSetup,
        transcript: &mut T,
        point: &[<Fr as JoltField>::Challenge],
        evaluation: &Fr,
        commitment: &ArkGT,
        gamma: Fq,
        delta: Fq,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        // Use Dory's witness_gen to generate witnesses
        let (witness_collection, _hints) = DoryCommitmentScheme::witness_gen(
            dory_proof,
            verifier_setup,
            transcript,
            point,
            evaluation,
            commitment,
        )?;

        println!("Witness collection: GT exp count = {}, GT mul count = {}",
                 witness_collection.gt_exp.len(),
                 witness_collection.gt_mul.len());

        // Convert witness collection to DoryRecursionWitness
        let recursion_witness = Self::witnesses_to_dory_recursion(&witness_collection)?;

        // Build constraint system from witness collection using DoryMatrixBuilder
        let constraint_system = Self::build_constraint_system(&witness_collection, recursion_witness.gt_exp_witness.g_poly.clone())?;

        Ok(Self {
            constraint_system,
            gamma,
            delta,
        })
    }

    /// Convert Dory witness collection to DoryRecursionWitness
    fn witnesses_to_dory_recursion(
        witnesses: &dory::recursion::WitnessCollection<crate::poly::commitment::dory::recursion::JoltWitness>,
    ) -> Result<DoryRecursionWitness, Box<dyn std::error::Error>> {
        use crate::zkvm::recursion::witness::{GTExpWitness, GTMulWitness};

        println!("Converting witnesses: GT exp count = {}, GT mul count = {}, G1 scalar mul count = {}",
                 witnesses.gt_exp.len(),
                 witnesses.gt_mul.len(),
                 witnesses.g1_scalar_mul.len());

        // Extract GT exp witness data
        let mut g_values = Vec::new();
        let mut bits = Vec::new();
        let mut base_values = Vec::new();
        let mut rho_values = Vec::new();
        let mut quotient_values = Vec::new();
        let mut scalar = Fr::zero();

        // Process GT exp witnesses
        for (_op_id, exp_witness) in witnesses.gt_exp.iter() {
            // Extract the scalar from the first witness
            if scalar.is_zero() && !exp_witness.exponent.is_zero() {
                scalar = exp_witness.exponent;
            }

            // Collect bits
            bits.extend(&exp_witness.bits);

            // For g_values and base_values, we need the rho MLEs which represent
            // the intermediate values during exponentiation
            for rho_mle in &exp_witness.rho_mles {
                g_values.extend(rho_mle);
                base_values.extend(rho_mle);
            }

            // Extract rho values from MLEs
            for rho_mle in &exp_witness.rho_mles {
                rho_values.extend(rho_mle);
            }

            // Extract quotient values from MLEs
            for quotient_mle in &exp_witness.quotient_mles {
                quotient_values.extend(quotient_mle);
            }
        }

        // Get the proper g(x) polynomial from jolt_optimizations
        // This is the irreducible polynomial defining the Fq12 extension field
        use jolt_optimizations::get_g_mle;
        use super::constraints_sys::DoryMatrixBuilder;

        let g_mle_4var = get_g_mle();

        // Pad g(x) to 8 variables (matching constraint system)
        let g_poly_values = DoryMatrixBuilder::pad_4var_to_8var(&g_mle_4var);
        let g_poly = DensePolynomial::new(g_poly_values.clone());
        g_values = g_poly_values;

        let gt_exp_witness = GTExpWitness {
            g_poly,
            g_values,
            scalar,
            bits,
            base_values,
            rho_values,
            quotient_values,
        };

        // Extract GT mul witness data
        let mut lhs_values = Vec::new();
        let mut rhs_values = Vec::new();
        let mut result_values = Vec::new();
        let mut gt_mul_quotient_values = Vec::new();

        for (_op_id, mul_witness) in witnesses.gt_mul.iter() {
            // For GT multiplication, we work with the quotient MLEs which are already in Fq
            // The actual lhs, rhs, result values come from the quotient decomposition
            gt_mul_quotient_values.extend(&mul_witness.quotient_mle);

            // For now, use placeholder values for lhs/rhs/result
            // In practice, these would be extracted from the quotient decomposition
            if !mul_witness.quotient_mle.is_empty() {
                lhs_values.push(mul_witness.quotient_mle[0]);
                rhs_values.push(mul_witness.quotient_mle[0]);
                result_values.push(mul_witness.quotient_mle[0]);
            }
        }

        let gt_mul_witness = GTMulWitness {
            lhs_values,
            rhs_values,
            result_values,
            quotient_values: gt_mul_quotient_values,
        };

        // Extract G1 scalar mul witness data
        let mut base_points = Vec::new();
        let mut scalars = Vec::new();
        let mut x_a_mles = Vec::new();
        let mut y_a_mles = Vec::new();
        let mut x_t_mles = Vec::new();
        let mut y_t_mles = Vec::new();
        let mut x_a_next_mles = Vec::new();
        let mut y_a_next_mles = Vec::new();
        let mut t_is_infinity_mles = Vec::new();

        for (_op_id, scalar_mul_witness) in witnesses.g1_scalar_mul.iter() {
            base_points.push(scalar_mul_witness.point_base);
            scalars.push(scalar_mul_witness.scalar);
            x_a_mles.extend(scalar_mul_witness.x_a_mles.clone());
            y_a_mles.extend(scalar_mul_witness.y_a_mles.clone());
            x_t_mles.extend(scalar_mul_witness.x_t_mles.clone());
            y_t_mles.extend(scalar_mul_witness.y_t_mles.clone());
            x_a_next_mles.extend(scalar_mul_witness.x_a_next_mles.clone());
            y_a_next_mles.extend(scalar_mul_witness.y_a_next_mles.clone());

            // Generate t_is_infinity MLEs based on the bits
            for (i, bit) in scalar_mul_witness.bits.iter().enumerate() {
                // T is infinity when bit is 0 (we don't add)
                let is_infinity = if !bit { Fq::one() } else { Fq::zero() };
                t_is_infinity_mles.push(vec![is_infinity]);
            }
        }

        let g1_scalar_mul_witness = G1ScalarMulWitness {
            base_points,
            scalars,
            x_a_mles,
            y_a_mles,
            x_t_mles,
            y_t_mles,
            x_a_next_mles,
            y_a_next_mles,
            t_is_infinity_mles,
        };

        Ok(DoryRecursionWitness {
            gt_exp_witness,
            gt_mul_witness,
            g1_scalar_mul_witness,
        })
    }

    /// Build constraint system from recursion witness
    fn build_constraint_system(
        witness_collection: &dory::recursion::WitnessCollection<crate::poly::commitment::dory::recursion::JoltWitness>,
        g_poly: DensePolynomial<Fq>,
    ) -> Result<ConstraintSystem, Box<dyn std::error::Error>> {
        use super::constraints_sys::DoryMatrixBuilder;

        // Use DoryMatrixBuilder with 8 variables for uniform matrix structure
        let mut builder = DoryMatrixBuilder::new(8);

        // Add GT exp witnesses
        for (_op_id, witness) in witness_collection.gt_exp.iter() {
            builder.add_gt_exp_witness(witness);
        }

        // Add GT mul witnesses
        for (_op_id, witness) in witness_collection.gt_mul.iter() {
            builder.add_gt_mul_witness(witness);
        }

        // Add G1 scalar mul witnesses
        for (_op_id, witness) in witness_collection.g1_scalar_mul.iter() {
            builder.add_g1_scalar_mul_witness(witness);
        }

        let (matrix, constraints) = builder.build();

        Ok(ConstraintSystem {
            constraints,
            matrix,
            g_poly,
        })
    }
}

impl<F: JoltField> RecursionProver<F> {
    /// Run the full two-stage recursion prover and generate PCS opening proof
    pub fn prove<T: Transcript, PCS: CommitmentScheme<Field = F> + RecursionExt<F>>(
        self,
        transcript: &mut T,
        prover_setup: &PCS::ProverSetup,
    ) -> Result<RecursionProof<F, T, PCS>, Box<dyn std::error::Error>> {
        use std::any::TypeId;

        // Runtime check that F = Fq for recursion SNARK
        if TypeId::of::<F>() != TypeId::of::<Fq>() {
            panic!("Recursion SNARK requires F = Fq");
        }
        // Initialize opening accumulator
        let log_T = self.constraint_system.num_vars();
        let mut accumulator = ProverOpeningAccumulator::<F>::new(log_T);

        // ============ STAGE 1: Constraint Sumchecks ============
        let (stage1_proof, r_stage1) = self.prove_stage1(transcript, &mut accumulator)?;

        // ============ STAGE 2: Virtualization Sumcheck ============
        let (stage2_proof, r_stage2) = self.prove_stage2(
            transcript,
            &mut accumulator,
            &r_stage1,
        )?;

        // ============ PCS OPENING PROOF ============
        // Create polynomial map for prove_single
        // Convert matrix evaluations from Fq to F (safe because F = Fq for recursion SNARK)
        let matrix_evaluations_f = unsafe {
            std::mem::transmute::<Vec<Fq>, Vec<F>>(
                self.constraint_system.matrix.evaluations.clone()
            )
        };
        let matrix_poly = MultilinearPolynomial::from(matrix_evaluations_f);
        let mut polynomials_map: HashMap<CommittedPolynomial, MultilinearPolynomial<F>> =
            HashMap::new();
        polynomials_map.insert(
            CommittedPolynomial::DoryConstraintMatrix,
            matrix_poly,
        );

        // Generate opening proof using PCS
        let opening_proof = accumulator
            .prove_single::<T, PCS>(
                polynomials_map,
                prover_setup,
                transcript,
            )
            .map_err(|e| format!("Failed to generate opening proof: {:?}", e))?;

        // Extract opening claims from accumulator
        let opening_claims = accumulator.openings.clone();

        // Create final proof
        let proof = RecursionProof {
            stage1_proof,
            stage2_proof,
            opening_proof,
            gamma: self.gamma,
            delta: self.delta,
            opening_claims,
        };

        Ok(proof)
    }

    /// Run the full two-stage recursion prover for any PCS (without requiring RecursionExt)
    pub fn prove_with_pcs<T: Transcript, PCS: CommitmentScheme<Field = F>>(
        self,
        transcript: &mut T,
        prover_setup: &PCS::ProverSetup,
    ) -> Result<RecursionProof<F, T, PCS>, Box<dyn std::error::Error>> {
        use std::any::TypeId;

        // Runtime check that F = Fq for recursion SNARK
        if TypeId::of::<F>() != TypeId::of::<Fq>() {
            panic!("Recursion SNARK requires F = Fq");
        }
        // Initialize opening accumulator
        let log_T = self.constraint_system.num_vars();
        let mut accumulator = ProverOpeningAccumulator::<F>::new(log_T);

        // ============ STAGE 1: Constraint Sumchecks ============
        let (stage1_proof, r_stage1) = self.prove_stage1(transcript, &mut accumulator)?;

        // ============ STAGE 2: Virtualization Sumcheck ============
        let (stage2_proof, _r_stage2) = self.prove_stage2(
            transcript,
            &mut accumulator,
            &r_stage1,
        )?;

        // ============ PCS OPENING PROOF ============
        // Create polynomial map for prove_single
        // Convert matrix evaluations from Fq to F (safe because F = Fq for recursion SNARK)
        let matrix_evaluations_f = unsafe {
            std::mem::transmute::<Vec<Fq>, Vec<F>>(
                self.constraint_system.matrix.evaluations.clone()
            )
        };
        let matrix_poly = MultilinearPolynomial::from(matrix_evaluations_f);
        let mut polynomials_map: HashMap<CommittedPolynomial, MultilinearPolynomial<F>> =
            HashMap::new();
        polynomials_map.insert(
            CommittedPolynomial::DoryConstraintMatrix,
            matrix_poly,
        );

        // Generate opening proof using PCS
        let opening_proof = accumulator
            .prove_single::<T, PCS>(
                polynomials_map,
                prover_setup,
                transcript,
            )
            .map_err(|e| format!("Failed to generate opening proof: {:?}", e))?;

        // Extract opening claims from accumulator
        let opening_claims = accumulator.openings.clone();

        // Create final proof
        let proof = RecursionProof {
            stage1_proof,
            stage2_proof,
            opening_proof,
            gamma: self.gamma,
            delta: self.delta,
            opening_claims,
        };

        Ok(proof)
    }


    /// Run Stage 1: Constraint sumchecks
    fn prove_stage1<T: Transcript>(
        &self,
        transcript: &mut T,
        accumulator: &mut ProverOpeningAccumulator<F>,
    ) -> Result<(crate::subprotocols::sumcheck::SumcheckInstanceProof<F, T>, Vec<<F as JoltField>::Challenge>), Box<dyn std::error::Error>> {
        use std::any::TypeId;

        // Runtime check that F = Fq for constraint system operations
        if TypeId::of::<F>() != TypeId::of::<Fq>() {
            panic!("Recursion SNARK constraint system requires F = Fq");
        }
        // Create provers for each constraint type
        let mut provers: Vec<Box<dyn SumcheckInstanceProver<F, T>>> = Vec::new();

        // Add GT exp prover if we have GT exp constraints
        let gt_exp_constraints = self.constraint_system.extract_constraint_polynomials();
        if !gt_exp_constraints.is_empty() {
            let params = SquareAndMultiplyParams::new(gt_exp_constraints.len());

            // Convert Fq constraints to F (safe because we checked F = Fq)
            let gt_exp_constraints_f = unsafe {
                std::mem::transmute::<
                    Vec<crate::zkvm::recursion::stage1::square_and_multiply::ConstraintPolynomials<Fq>>,
                    Vec<crate::zkvm::recursion::stage1::square_and_multiply::ConstraintPolynomials<F>>
                >(gt_exp_constraints)
            };

            // Convert g_poly from Fq to F
            let g_poly_f = unsafe {
                std::mem::transmute::<DensePolynomial<Fq>, DensePolynomial<F>>(
                    self.constraint_system.g_poly.clone()
                )
            };

            let prover = SquareAndMultiplyProver::new(
                params,
                gt_exp_constraints_f,
                g_poly_f,
                transcript,
            );
            provers.push(Box::new(prover));
        }

        // Add GT mul prover if we have GT mul constraints
        let gt_mul_constraints_tuples = self.constraint_system.extract_gt_mul_constraints();
        if !gt_mul_constraints_tuples.is_empty() {
            use super::stage1::gt_mul::GtMulConstraintPolynomials;

            // Convert tuples to structured type
            let gt_mul_constraints_fq: Vec<GtMulConstraintPolynomials<Fq>> = gt_mul_constraints_tuples
                .into_iter()
                .map(|(idx, lhs, rhs, result, quotient)| GtMulConstraintPolynomials {
                    lhs,
                    rhs,
                    result,
                    quotient,
                    constraint_index: idx,
                })
                .collect();

            let params = GtMulParams::new(gt_mul_constraints_fq.len());

            // Convert Fq constraints to F (safe because we checked F = Fq)
            let gt_mul_constraints_f = unsafe {
                std::mem::transmute::<
                    Vec<GtMulConstraintPolynomials<Fq>>,
                    Vec<GtMulConstraintPolynomials<F>>
                >(gt_mul_constraints_fq)
            };

            // Convert g_poly from Fq to F
            let g_poly_f = unsafe {
                std::mem::transmute::<DensePolynomial<Fq>, DensePolynomial<F>>(
                    self.constraint_system.g_poly.clone()
                )
            };

            let prover = GtMulProver::new(
                params,
                gt_mul_constraints_f,
                g_poly_f,
                transcript,
            );
            provers.push(Box::new(prover));
        }

        // Add G1 scalar mul prover if we have G1 scalar mul constraints
        let g1_scalar_mul_constraints_tuples = self.constraint_system.extract_g1_scalar_mul_constraints();
        if !g1_scalar_mul_constraints_tuples.is_empty() {
            use super::stage1::g1_scalar_mul::G1ScalarMulConstraintPolynomials;

            // Convert tuples to structured type
            let g1_scalar_mul_constraints: Vec<G1ScalarMulConstraintPolynomials> = g1_scalar_mul_constraints_tuples
                .into_iter()
                .map(|(idx, base_point, x_a, y_a, x_t, y_t, x_a_next, y_a_next, t_is_infinity)| {
                    G1ScalarMulConstraintPolynomials {
                        x_a,
                        y_a,
                        x_t,
                        y_t,
                        x_a_next,
                        y_a_next,
                        t_is_infinity,
                        base_point,
                        constraint_index: idx,
                    }
                })
                .collect();

            let params = G1ScalarMulParams::new(g1_scalar_mul_constraints.len());
            let prover = G1ScalarMulProver::new(
                params,
                g1_scalar_mul_constraints,
                transcript,
            );
            provers.push(Box::new(prover));
        }

        if provers.is_empty() {
            return Err("No constraints to prove in Stage 1".into());
        }

        // Run batched sumcheck for all provers
        let (proof, r_stage1) = BatchedSumcheck::prove(
            provers.iter_mut().map(|p| &mut **p as _).collect(),
            accumulator,
            transcript,
        );

        Ok((proof, r_stage1))
    }

    /// Run Stage 2: Virtualization sumcheck
    fn prove_stage2<T: Transcript>(
        &self,
        transcript: &mut T,
        accumulator: &mut ProverOpeningAccumulator<F>,
        r_stage1: &[<F as JoltField>::Challenge],
    ) -> Result<(crate::subprotocols::sumcheck::SumcheckInstanceProof<F, T>, Vec<<F as JoltField>::Challenge>), Box<dyn std::error::Error>> {
        use std::any::TypeId;

        // Runtime check that F = Fq for constraint system operations
        if TypeId::of::<F>() != TypeId::of::<Fq>() {
            panic!("Recursion SNARK constraint system requires F = Fq");
        }
        // Create virtualization parameters
        let num_s_vars = self.constraint_system.num_s_vars();
        let num_constraints = self.constraint_system.num_constraints();
        let num_constraints_padded = self.constraint_system.matrix.num_constraints_padded;

        let params = RecursionVirtualizationParams::new(
            num_s_vars,
            num_constraints,
            num_constraints_padded,
            CommittedPolynomial::DoryConstraintMatrix,
        );

        // Create virtualization prover
        let mut prover = RecursionVirtualizationProver::new(
            params,
            &self.constraint_system,
            transcript,
            r_stage1.to_vec(),
            accumulator,
            self.gamma,
        );

        // Run virtualization sumcheck
        let (proof, r_stage2) = BatchedSumcheck::prove(
            vec![&mut prover],
            accumulator,
            transcript,
        );

        Ok((proof, r_stage2))
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_recursion_prover_creation() {
        // TODO: Add test for prover creation
    }
}