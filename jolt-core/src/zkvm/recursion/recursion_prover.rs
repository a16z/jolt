//! Unified prover for the two-stage recursion SNARK protocol
//!
//! This module provides a high-level prover that orchestrates:
//! - Stage 1: Constraint sumchecks (GT exp, GT mul, G1 scalar mul)
//! - Stage 2: Virtualization sumcheck
//!
//! The prover returns a proof and opening accumulator for PCS verification.

use crate::{
    field::JoltField,
    poly::{
        commitment::{
            commitment_scheme::{CommitmentScheme, RecursionExt},
            dory::{wrappers::ArkDoryProof, ArkworksVerifierSetup, DoryCommitmentScheme},
        },
        dense_mlpoly::DensePolynomial,
        multilinear_polynomial::MultilinearPolynomial,
        opening_proof::{OpeningAccumulator, Openings, ProverOpeningAccumulator, SumcheckId},
    },
    transcripts::Transcript,
    zkvm::{
        recursion::witness::{DoryRecursionWitness, G1ScalarMulWitness},
        witness::{CommittedPolynomial, VirtualPolynomial},
    },
};
use ark_bn254::{Fq, Fr};
use ark_ff::{One, Zero};
use ark_serialize::{CanonicalDeserialize, CanonicalSerialize};
use dory::backends::arkworks::ArkGT;
use std::collections::HashMap;

use crate::zkvm::recursion::DoryMatrixBuilder;

use super::{
    constraints_sys::{ConstraintSystem, ConstraintType},
    stage1::{
        g1_scalar_mul::{G1ScalarMulParams, G1ScalarMulProver},
        gt_mul::{GtMulParams, GtMulProver},
        packed_gt_exp::{PackedGtExpParams, PackedGtExpProver, PackedGtExpPublicInputs},
    },
    stage2::virtualization::{
        DirectEvaluationParams, DirectEvaluationProver,
        extract_virtual_claims_from_accumulator,
    },
    stage3::{
        jagged::JaggedSumcheckProver,
        jagged_assist::{JaggedAssistProof, JaggedAssistProver},
    },
};
use crate::subprotocols::{sumcheck::BatchedSumcheck, sumcheck_prover::SumcheckInstanceProver};

/// Proof generated by the recursion SNARK
#[derive(Clone, Debug, CanonicalSerialize, CanonicalDeserialize)]
pub struct RecursionProof<F: JoltField, T: Transcript, PCS: CommitmentScheme<Field = F>> {
    /// Stage 1 constraint sumcheck proof
    pub stage1_proof: crate::subprotocols::sumcheck::SumcheckInstanceProof<F, T>,
    /// Stage 2 direct evaluation result M(r_s, r_x)
    pub stage2_m_eval: F,
    /// Stage 3 jagged transform sumcheck proof
    pub stage3_proof: crate::subprotocols::sumcheck::SumcheckInstanceProof<F, T>,
    /// Stage 3b jagged assist proof (batch MLE verification)
    pub stage3b_proof: JaggedAssistProof<F, T>,
    /// PCS opening proof for the constraint matrix
    pub opening_proof: PCS::Proof,
    /// Gamma value used for batching constraints
    pub gamma: F,
    /// Delta value used for batching within constraints
    pub delta: F,
    /// Opening claims for virtual polynomials
    pub opening_claims: Openings<F>,
    /// Dense polynomial commitment after jagged transform
    pub dense_commitment: PCS::Commitment,
}

/// Type alias for readability
/// Unified prover for the recursion SNARK
#[derive(Clone)]
pub struct RecursionProver<F: JoltField = Fq> {
    /// The constraint system containing all constraints and witness data
    pub constraint_system: ConstraintSystem,
    /// Gamma value for batching across constraints
    pub gamma: F,
    /// Delta value for batching within constraints
    pub delta: F,
}

impl RecursionProver<Fq> {
    /// Create a new recursion prover from pre-generated witnesses
    pub fn new_from_witnesses(
        witness_collection: &dory::recursion::WitnessCollection<
            crate::poly::commitment::dory::recursion::JoltWitness,
        >,
        combine_witness: Option<crate::zkvm::recursion::witness::GTCombineWitness>,
        gamma: Fq,
        delta: Fq,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        tracing::debug!(
            "Creating RecursionProver from witnesses: GT exp count = {}, GT mul count = {}",
            witness_collection.gt_exp.len(),
            witness_collection.gt_mul.len()
        );

        // Convert witness collection to DoryRecursionWitness
        let recursion_witness = Self::witnesses_to_dory_recursion(&witness_collection, combine_witness.clone())?;

        // Build constraint system from witness collection using DoryMatrixBuilder
        let build_cs_span = tracing::info_span!("build_constraint_system").entered();
        let constraint_system = Self::build_constraint_system(
            &witness_collection,
            recursion_witness.combine_witness.as_ref(),
            recursion_witness.gt_exp_witness.g_poly.clone(),
        )?;
        drop(build_cs_span);

        Ok(Self {
            constraint_system,
            gamma,
            delta,
        })
    }

    /// Create a new recursion prover by generating witnesses from a Dory proof
    pub fn new_from_dory_proof<T: Transcript>(
        dory_proof: &ArkDoryProof,
        verifier_setup: &ArkworksVerifierSetup,
        transcript: &mut T,
        point: &[<Fr as JoltField>::Challenge],
        evaluation: &Fr,
        commitment: &ArkGT,
        gamma: Fq,
        delta: Fq,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        // Use Dory's witness_gen to generate witnesses
        let (witness_collection, _hints) = DoryCommitmentScheme::witness_gen(
            dory_proof,
            verifier_setup,
            transcript,
            point,
            evaluation,
            commitment,
        )?;

        // Delegate to new_from_witnesses (no combine_witness from direct Dory proof)
        Self::new_from_witnesses(&witness_collection, None, gamma, delta)
    }

    /// Convert Dory witness collection to DoryRecursionWitness
    fn witnesses_to_dory_recursion(
        witnesses: &dory::recursion::WitnessCollection<
            crate::poly::commitment::dory::recursion::JoltWitness,
        >,
        combine_witness: Option<crate::zkvm::recursion::witness::GTCombineWitness>,
    ) -> Result<DoryRecursionWitness, Box<dyn std::error::Error>> {
        let _span = tracing::info_span!("witnesses_to_dory_recursion").entered();

        use crate::zkvm::recursion::witness::{GTExpWitness, GTMulWitness};

        tracing::debug!(
            "Converting witnesses: GT exp count = {}, GT mul count = {}, G1 scalar mul count = {}",
            witnesses.gt_exp.len(),
            witnesses.gt_mul.len(),
            witnesses.g1_scalar_mul.len()
        );

        // Extract GT exp witness data with preallocation
        let gt_exp_span = tracing::info_span!("process_gt_exp_witnesses").entered();

        // Calculate total sizes for preallocation
        let total_bits = witnesses.gt_exp.iter().map(|(_, w)| w.bits.len()).sum();
        let total_rho_elements: usize = witnesses
            .gt_exp
            .iter()
            .map(|(_, w)| w.rho_mles.iter().map(|mle| mle.len()).sum::<usize>())
            .sum();
        let total_quotient_elements: usize = witnesses
            .gt_exp
            .iter()
            .map(|(_, w)| w.quotient_mles.iter().map(|mle| mle.len()).sum::<usize>())
            .sum();

        let mut bits = Vec::with_capacity(total_bits);
        let mut base_values = Vec::with_capacity(total_rho_elements);
        let mut rho_values = Vec::with_capacity(total_rho_elements);
        let mut quotient_values = Vec::with_capacity(total_quotient_elements);
        let mut scalar = Fr::zero();

        // Process GT exp witnesses
        for (_op_id, exp_witness) in witnesses.gt_exp.iter() {
            // Extract the scalar from the first witness
            if scalar.is_zero() && !exp_witness.exponent.is_zero() {
                scalar = exp_witness.exponent;
            }

            // Collect bits
            bits.extend(&exp_witness.bits);

            // Process rho MLEs once, copying to both vectors
            for rho_mle in &exp_witness.rho_mles {
                base_values.extend(rho_mle);
                rho_values.extend(rho_mle);
            }

            // Extract quotient values from MLEs
            for quotient_mle in &exp_witness.quotient_mles {
                quotient_values.extend(quotient_mle);
            }
        }
        drop(gt_exp_span);

        // Get the proper g(x) polynomial from jolt_optimizations
        // This is the irreducible polynomial defining the Fq12 extension field
        let g_poly_span = tracing::info_span!("process_g_polynomial").entered();
        use super::constraints_sys::DoryMatrixBuilder;
        use jolt_optimizations::get_g_mle;

        let g_mle_4var = get_g_mle();

        // Pad g(x) to 12 variables (matching constraint system)
        let g_poly_values = DoryMatrixBuilder::pad_4var_to_12var_zero_padding(&g_mle_4var);
        let g_poly = DensePolynomial::new(g_poly_values.clone());
        let g_values = g_poly_values;
        drop(g_poly_span);

        let gt_exp_witness = GTExpWitness {
            g_poly,
            g_values,
            scalar,
            bits,
            base_values,
            rho_values,
            quotient_values,
        };

        // Extract GT mul witness data with preallocation
        let gt_mul_span = tracing::info_span!("process_gt_mul_witnesses").entered();

        let total_mul_quotient_elements: usize = witnesses
            .gt_mul
            .iter()
            .map(|(_, w)| w.quotient_mle.len())
            .sum();

        let mut lhs_values = Vec::with_capacity(witnesses.gt_mul.len());
        let mut rhs_values = Vec::with_capacity(witnesses.gt_mul.len());
        let mut result_values = Vec::with_capacity(witnesses.gt_mul.len());
        let mut gt_mul_quotient_values = Vec::with_capacity(total_mul_quotient_elements);

        for (_op_id, mul_witness) in witnesses.gt_mul.iter() {
            // For GT multiplication, we work with the quotient MLEs which are already in Fq
            // The actual lhs, rhs, result values come from the quotient decomposition
            gt_mul_quotient_values.extend(&mul_witness.quotient_mle);

            // For now, use placeholder values for lhs/rhs/result
            // In practice, these would be extracted from the quotient decomposition
            if !mul_witness.quotient_mle.is_empty() {
                lhs_values.push(mul_witness.quotient_mle[0]);
                rhs_values.push(mul_witness.quotient_mle[0]);
                result_values.push(mul_witness.quotient_mle[0]);
            }
        }
        drop(gt_mul_span);

        let gt_mul_witness = GTMulWitness {
            lhs_values,
            rhs_values,
            result_values,
            quotient_values: gt_mul_quotient_values,
        };

        // Extract G1 scalar mul witness data with preallocation
        let g1_scalar_mul_span = tracing::info_span!("process_g1_scalar_mul_witnesses").entered();

        let num_g1_witnesses = witnesses.g1_scalar_mul.len();
        let total_bits: usize = witnesses
            .g1_scalar_mul
            .iter()
            .map(|(_, w)| w.bits.len())
            .sum();

        let mut base_points = Vec::with_capacity(num_g1_witnesses);
        let mut scalars = Vec::with_capacity(num_g1_witnesses);
        let mut x_a_mles = Vec::new();
        let mut y_a_mles = Vec::new();
        let mut x_t_mles = Vec::new();
        let mut y_t_mles = Vec::new();
        let mut x_a_next_mles = Vec::new();
        let mut y_a_next_mles = Vec::new();
        let mut t_is_infinity_mles = Vec::with_capacity(total_bits);

        for (_op_id, scalar_mul_witness) in witnesses.g1_scalar_mul.iter() {
            base_points.push(scalar_mul_witness.point_base);
            scalars.push(scalar_mul_witness.scalar);

            // Use iterators to avoid cloning - just extend from the slice
            x_a_mles.extend_from_slice(&scalar_mul_witness.x_a_mles);
            y_a_mles.extend_from_slice(&scalar_mul_witness.y_a_mles);
            x_t_mles.extend_from_slice(&scalar_mul_witness.x_t_mles);
            y_t_mles.extend_from_slice(&scalar_mul_witness.y_t_mles);
            x_a_next_mles.extend_from_slice(&scalar_mul_witness.x_a_next_mles);
            y_a_next_mles.extend_from_slice(&scalar_mul_witness.y_a_next_mles);

            // Generate t_is_infinity MLEs based on the bits
            for bit in scalar_mul_witness.bits.iter() {
                // T is infinity when bit is 0 (we don't add)
                let is_infinity = if !bit { Fq::one() } else { Fq::zero() };
                t_is_infinity_mles.push(vec![is_infinity]);
            }
        }
        drop(g1_scalar_mul_span);

        let g1_scalar_mul_witness = G1ScalarMulWitness {
            base_points,
            scalars,
            x_a_mles,
            y_a_mles,
            x_t_mles,
            y_t_mles,
            x_a_next_mles,
            y_a_next_mles,
            t_is_infinity_mles,
        };

        if let Some(ref cw) = combine_witness {
            tracing::info!(
                "[Homomorphic Combine] Merging combine_witness: {} exp ops, {} mul ops",
                cw.exp_witnesses.len(),
                cw.mul_witnesses.len()
            );
        }

        Ok(DoryRecursionWitness {
            gt_exp_witness,
            gt_mul_witness,
            g1_scalar_mul_witness,
            combine_witness,
        })
    }

    /// Build constraint system from recursion witness
    fn build_constraint_system(
        witness_collection: &dory::recursion::WitnessCollection<
            crate::poly::commitment::dory::recursion::JoltWitness,
        >,
        combine_witness: Option<&crate::zkvm::recursion::witness::GTCombineWitness>,
        g_poly: DensePolynomial<Fq>,
    ) -> Result<ConstraintSystem, Box<dyn std::error::Error>> {
        use super::constraints_sys::DoryMatrixBuilder;
        use super::stage1::packed_gt_exp::PackedGtExpWitness;
        use jolt_optimizations::fq12_to_multilinear_evals;

        // Use DoryMatrixBuilder with 12 variables for uniform matrix structure (packed GT exp)
        let mut builder = DoryMatrixBuilder::new(12);

        // Build packed GT exp witnesses and add to matrix
        tracing::info!(
            "[build_constraint_system] Processing {} direct GT exp witnesses",
            witness_collection.gt_exp.len()
        );
        let packed_gt_exp_span = tracing::info_span!(
            "build_packed_gt_exp_witnesses",
            count = witness_collection.gt_exp.len()
        )
        .entered();
        let mut packed_gt_exp_witnesses = Vec::with_capacity(witness_collection.gt_exp.len());
        let mut packed_gt_exp_public_inputs = Vec::with_capacity(witness_collection.gt_exp.len());
        for (_op_id, witness) in witness_collection.gt_exp.iter() {
            // Convert base ArkGT to 4-var MLE
            let base_mle = fq12_to_multilinear_evals(&witness.base);

            // Create packed witness
            let packed = PackedGtExpWitness::from_steps(
                &witness.rho_mles,
                &witness.quotient_mles,
                &witness.bits,
                &base_mle,
            );

            // Add to matrix (ONE constraint per packed GT exp)
            builder.add_packed_gt_exp_witness(&packed);

            // Keep for Stage 1 prover
            packed_gt_exp_witnesses.push(packed);

            // Store public inputs for verifier
            packed_gt_exp_public_inputs.push(PackedGtExpPublicInputs::new(
                witness.base,
                witness.bits.clone(),
            ));
        }
        drop(packed_gt_exp_span);

        // Add GT mul witnesses
        let gt_mul_span = tracing::info_span!(
            "add_gt_mul_witnesses",
            count = witness_collection.gt_mul.len()
        )
        .entered();
        for (_op_id, witness) in witness_collection.gt_mul.iter() {
            builder.add_gt_mul_witness(witness);
        }
        drop(gt_mul_span);

        // Add G1 scalar mul witnesses
        let g1_scalar_mul_span = tracing::info_span!(
            "add_g1_scalar_mul_witnesses",
            count = witness_collection.g1_scalar_mul.len()
        )
        .entered();
        for (_op_id, witness) in witness_collection.g1_scalar_mul.iter() {
            builder.add_g1_scalar_mul_witness(witness);
        }
        drop(g1_scalar_mul_span);

        // Add combine_commitments witnesses (homomorphic combine offloading)
        if let Some(cw) = combine_witness {
            let pre_count = builder.constraint_count();
            tracing::info!(
                "[Homomorphic Combine] Adding {} GT exp + {} GT mul constraints (pre-count: {})",
                cw.exp_witnesses.len(),
                cw.mul_witnesses.len(),
                pre_count
            );

            // Also collect public inputs for the combine witnesses
            for exp_wit in &cw.exp_witnesses {
                packed_gt_exp_public_inputs.push(PackedGtExpPublicInputs::new(
                    exp_wit.base,
                    exp_wit.bits.clone(),
                ));
            }

            let combined_packed_witnesses = builder.add_combine_witness(cw);
            tracing::info!(
                "[Homomorphic Combine] Post-add constraint count: {}, packed witnesses: {}",
                builder.constraint_count(),
                combined_packed_witnesses.len()
            );
            // Add the combined witnesses to our list
            tracing::info!(
                "[Homomorphic Combine] Before extend: {} witnesses, adding {} more",
                packed_gt_exp_witnesses.len(),
                combined_packed_witnesses.len()
            );
            packed_gt_exp_witnesses.extend(combined_packed_witnesses);
        }

        let build_matrix_span = tracing::info_span!("build_matrix").entered();
        let (matrix, constraints) = builder.build();
        drop(build_matrix_span);

        Ok(ConstraintSystem {
            constraints,
            matrix,
            g_poly,
            packed_gt_exp_witnesses,
            packed_gt_exp_public_inputs,
        })
    }
}

impl<F: JoltField> RecursionProver<F> {
    /// Run the full two-stage recursion prover and generate PCS opening proof
    pub fn prove<T: Transcript, PCS: CommitmentScheme<Field = F> + RecursionExt<F>>(
        self,
        transcript: &mut T,
        prover_setup: &PCS::ProverSetup,
    ) -> Result<RecursionProof<F, T, PCS>, Box<dyn std::error::Error>> {
        // Delegate to prove_with_pcs - the RecursionExt trait bound is not actually used
        self.prove_with_pcs(transcript, prover_setup)
    }

    /// Run the full two-stage recursion prover for any PCS (without requiring RecursionExt)
    #[tracing::instrument(skip_all, name = "RecursionProver::prove_with_pcs")]
    pub fn prove_with_pcs<T: Transcript, PCS: CommitmentScheme<Field = F>>(
        self,
        transcript: &mut T,
        prover_setup: &PCS::ProverSetup,
    ) -> Result<RecursionProof<F, T, PCS>, Box<dyn std::error::Error>> {
        use std::any::TypeId;

        // Runtime check that F = Fq for recursion SNARK
        if TypeId::of::<F>() != TypeId::of::<Fq>() {
            panic!("Recursion SNARK requires F = Fq");
        }
        // Initialize opening accumulator
        let log_T = self.constraint_system.num_vars();
        let mut accumulator = ProverOpeningAccumulator::<F>::new(log_T);

        // ============ STAGE 1: Constraint Sumchecks ============
        tracing::info_span!("recursion_stage1_sumchecks").in_scope(|| {
            tracing::info!("Starting Stage 1: Constraint sumchecks");
        });
        let (stage1_proof, r_stage1) = self.prove_stage1(transcript, &mut accumulator)?;

        // ============ STAGE 2: Virtualization Sumcheck ============
        tracing::info_span!("recursion_stage2_virtualization").in_scope(|| {
            tracing::info!("Starting Stage 2: Virtualization sumcheck");
        });
        let (stage2_m_eval, r_stage2) =
            self.prove_stage2(transcript, &mut accumulator, &r_stage1)?;

        // ============ STAGE 3: Jagged Transform Sumcheck + Stage 3b: Jagged Assist ============
        tracing::info_span!("recursion_stage3_jagged").in_scope(|| {
            tracing::info!("Starting Stage 3: Jagged transform sumcheck");
        });
        let (stage3_proof, stage3b_proof, _r_stage3) =
            self.prove_stage3(transcript, &mut accumulator, &r_stage1, &r_stage2)?;

        // ============ PCS OPENING PROOF ============
        tracing::info_span!("recursion_pcs_opening_proof").in_scope(|| {
            tracing::info!("Starting PCS opening proof generation");
        });

        // Now we commit to the dense polynomial instead of the full matrix
        let (dense_poly, _bijection, _mapping) = self.constraint_system.build_dense_polynomial();

        // Convert dense polynomial evaluations to F
        let dense_evaluations_f = unsafe { std::mem::transmute::<Vec<Fq>, Vec<F>>(dense_poly.Z) };
        let dense_matrix_poly = MultilinearPolynomial::from(dense_evaluations_f.clone());

        // Commit to the dense polynomial
        let (dense_commitment, _) = PCS::commit(&dense_matrix_poly, prover_setup);

        let mut polynomials_map: HashMap<CommittedPolynomial, MultilinearPolynomial<F>> =
            HashMap::new();
        polynomials_map.insert(CommittedPolynomial::DoryDenseMatrix, dense_matrix_poly);

        // Generate opening proof using PCS
        let opening_proof = accumulator
            .prove_single::<T, PCS>(polynomials_map, prover_setup, transcript)
            .map_err(|e| format!("Failed to generate opening proof: {:?}", e))?;

        // Extract opening claims from accumulator
        let opening_claims = accumulator.openings.clone();

        // Create final proof
        let proof = RecursionProof {
            stage1_proof,
            stage2_m_eval,
            stage3_proof,
            stage3b_proof,
            opening_proof,
            gamma: self.gamma,
            delta: self.delta,
            opening_claims,
            dense_commitment,
        };

        Ok(proof)
    }

    /// Run Stage 1: Constraint sumchecks
    #[tracing::instrument(skip_all, name = "RecursionProver::prove_stage1")]
    pub(crate) fn prove_stage1<T: Transcript>(
        &self,
        transcript: &mut T,
        accumulator: &mut ProverOpeningAccumulator<F>,
    ) -> Result<
        (
            crate::subprotocols::sumcheck::SumcheckInstanceProof<F, T>,
            Vec<<F as JoltField>::Challenge>,
        ),
        Box<dyn std::error::Error>,
    > {
        use std::any::TypeId;

        // Runtime check that F = Fq for constraint system operations
        if TypeId::of::<F>() != TypeId::of::<Fq>() {
            panic!("Recursion SNARK constraint system requires F = Fq");
        }

        // Convert g_poly for GT mul (uses zero padding layout: s * 16 + x)
        let g_poly_f = unsafe {
            std::mem::transmute::<DensePolynomial<Fq>, DensePolynomial<F>>(
                self.constraint_system.g_poly.clone(),
            )
        };

        // Create provers for each constraint type
        let mut provers: Vec<Box<dyn SumcheckInstanceProver<F, T>>> = Vec::new();

        // Add packed GT exp prover (single prover handles all witnesses with gamma batching)
        let packed_witnesses = &self.constraint_system.packed_gt_exp_witnesses;
        if !packed_witnesses.is_empty() {
            // Packed GT exp uses layout x * 256 + s (s in low bits), so g needs replication
            // Extract 4-var g from the zero-padded version and replicate across s
            let g_4var: Vec<Fq> = self.constraint_system.g_poly.evals()[0..16].to_vec();
            let g_replicated = DoryMatrixBuilder::pad_4var_to_12var_replicated(&g_4var);
            let g_poly_replicated_f = unsafe {
                std::mem::transmute::<DensePolynomial<Fq>, DensePolynomial<F>>(
                    DensePolynomial::new(g_replicated),
                )
            };

            let params = PackedGtExpParams::new();
            tracing::info!(
                "[Stage 1] Creating PackedGtExpProver with {} witnesses",
                packed_witnesses.len()
            );
            let prover =
                PackedGtExpProver::new(params, packed_witnesses, g_poly_replicated_f, transcript);
            provers.push(Box::new(prover));
        }

        // Add GT mul prover if we have GT mul constraints
        let gt_mul_constraints_tuples = self.constraint_system.extract_gt_mul_constraints();
        if !gt_mul_constraints_tuples.is_empty() {
            use super::stage1::gt_mul::GtMulConstraintPolynomials;

            // Convert tuples to structured type
            let gt_mul_constraints_fq: Vec<GtMulConstraintPolynomials<Fq>> =
                gt_mul_constraints_tuples
                    .into_iter()
                    .map(
                        |(idx, lhs, rhs, result, quotient)| GtMulConstraintPolynomials {
                            lhs,
                            rhs,
                            result,
                            quotient,
                            constraint_index: idx,
                        },
                    )
                    .collect();

            let params = GtMulParams::new(gt_mul_constraints_fq.len());

            // Convert Fq constraints to F (safe because we checked F = Fq)
            let gt_mul_constraints_f = unsafe {
                std::mem::transmute::<
                    Vec<GtMulConstraintPolynomials<Fq>>,
                    Vec<GtMulConstraintPolynomials<F>>,
                >(gt_mul_constraints_fq)
            };

            let prover =
                GtMulProver::new(params, gt_mul_constraints_f, g_poly_f.clone(), transcript);
            provers.push(Box::new(prover));
        }

        // Add G1 scalar mul prover if we have G1 scalar mul constraints
        let g1_scalar_mul_constraints_tuples =
            self.constraint_system.extract_g1_scalar_mul_constraints();
        if !g1_scalar_mul_constraints_tuples.is_empty() {
            use super::stage1::g1_scalar_mul::G1ScalarMulConstraintPolynomials;

            // Convert tuples to structured type
            let g1_scalar_mul_constraints: Vec<G1ScalarMulConstraintPolynomials> =
                g1_scalar_mul_constraints_tuples
                    .into_iter()
                    .map(
                        |(
                            idx,
                            base_point,
                            x_a,
                            y_a,
                            x_t,
                            y_t,
                            x_a_next,
                            y_a_next,
                            t_is_infinity,
                        )| {
                            G1ScalarMulConstraintPolynomials {
                                x_a,
                                y_a,
                                x_t,
                                y_t,
                                x_a_next,
                                y_a_next,
                                t_is_infinity,
                                base_point,
                                constraint_index: idx,
                            }
                        },
                    )
                    .collect();

            let params = G1ScalarMulParams::new(g1_scalar_mul_constraints.len());
            let prover = G1ScalarMulProver::new(params, g1_scalar_mul_constraints, transcript);
            provers.push(Box::new(prover));
        }

        if provers.is_empty() {
            return Err("No constraints to prove in Stage 1".into());
        }

        // Run batched sumcheck for all provers
        let (proof, r_stage1) = BatchedSumcheck::prove(
            provers.iter_mut().map(|p| &mut **p as _).collect(),
            accumulator,
            transcript,
        );

        Ok((proof, r_stage1))
    }

    /// Run Stage 2: Direct evaluation protocol
    #[tracing::instrument(skip_all, name = "RecursionProver::prove_stage2")]
    pub(crate) fn prove_stage2<T: Transcript>(
        &self,
        transcript: &mut T,
        accumulator: &mut ProverOpeningAccumulator<F>,
        r_stage1: &[<F as JoltField>::Challenge],
    ) -> Result<
        (
            F, // Return m_eval instead of sumcheck proof
            Vec<<F as JoltField>::Challenge>,
        ),
        Box<dyn std::error::Error>,
    > {
        use std::any::TypeId;

        // Runtime check that F = Fq for constraint system operations
        if TypeId::of::<F>() != TypeId::of::<Fq>() {
            panic!("Recursion SNARK constraint system requires F = Fq");
        }

        // Since we know F = Fq, we can work directly with Fq types
        let accumulator_fq: &mut ProverOpeningAccumulator<Fq> = unsafe { std::mem::transmute(accumulator) };

        // Convert r_stage1 challenges to Fq field elements
        // SAFETY: We verified F = Fq above, so F::Challenge = Fq::Challenge
        let r_x: Vec<Fq> = unsafe {
            let r_stage1_fq: &[<Fq as JoltField>::Challenge] = std::mem::transmute(r_stage1);
            r_stage1_fq.iter().map(|c| (*c).into()).collect()
        };

        // Extract virtual claims from Stage 1
        let constraint_types: Vec<ConstraintType> = self.constraint_system.constraints
            .iter()
            .map(|c| c.constraint_type.clone())
            .collect();
        let virtual_claims = extract_virtual_claims_from_accumulator(
            accumulator_fq,
            &constraint_types,
            &self.constraint_system.packed_gt_exp_public_inputs,
        );

        // Create parameters
        let params = DirectEvaluationParams::new(
            self.constraint_system.num_s_vars(),
            self.constraint_system.num_constraints(),
            self.constraint_system.matrix.num_constraints_padded,
            self.constraint_system.matrix.num_constraint_vars,
        );

        // Create and run prover
        let prover = DirectEvaluationProver::new(
            params,
            self.constraint_system.matrix.evaluations.clone(),
            virtual_claims,
            r_x.clone(),
        );

        let (r_s, m_eval) = prover.prove(transcript, accumulator_fq);

        // Convert r_s to challenges for Stage 3 compatibility
        // Stage 3 expects them in reverse order
        // SAFETY: We verified F = Fq above
        let r_stage2: Vec<<F as JoltField>::Challenge> = unsafe {
            let r_s_challenges: Vec<<Fq as JoltField>::Challenge> = r_s
                .into_iter()
                .rev()
                .map(|f| f.into())
                .collect();
            std::mem::transmute(r_s_challenges)
        };

        // Convert m_eval from Fq to F
        // SAFETY: We verified F = Fq above
        let m_eval_f: F = unsafe { std::mem::transmute_copy(&m_eval) };

        Ok((m_eval_f, r_stage2))
    }

    /// Run Stage 3: Jagged Transform Sumcheck + Stage 3b: Jagged Assist
    #[tracing::instrument(skip_all, name = "RecursionProver::prove_stage3")]
    pub(crate) fn prove_stage3<T: Transcript>(
        &self,
        transcript: &mut T,
        accumulator: &mut ProverOpeningAccumulator<F>,
        r_stage1: &[<F as JoltField>::Challenge],
        r_stage2: &[<F as JoltField>::Challenge],
    ) -> Result<
        (
            crate::subprotocols::sumcheck::SumcheckInstanceProof<F, T>,
            JaggedAssistProof<F, T>,
            Vec<<F as JoltField>::Challenge>,
        ),
        Box<dyn std::error::Error>,
    > {
        use std::any::TypeId;

        // Runtime check that F = Fq for constraint system operations
        if TypeId::of::<F>() != TypeId::of::<Fq>() {
            panic!("Recursion SNARK constraint system requires F = Fq");
        }

        // Get the opening claim from Stage 2 using explicit key lookup (not .last() which depends on insertion order)
        let (_, sparse_claim_value) = accumulator.get_virtual_polynomial_opening(
            VirtualPolynomial::DorySparseConstraintMatrix,
            SumcheckId::RecursionVirtualization,
        );

        // Build dense polynomial, bijection, and mapping
        let (dense_poly_fq, bijection, mapping) = self.constraint_system.build_dense_polynomial();

        // Convert dense polynomial from Fq to F (safe because F = Fq in recursion)
        let dense_poly_f = DensePolynomial {
            num_vars: dense_poly_fq.num_vars,
            len: dense_poly_fq.len,
            Z: unsafe { std::mem::transmute(dense_poly_fq.Z) },
        };

        // Convert r_stage2 (s challenges) and r_stage1 (x challenges) to F
        let r_s_final: Vec<F> = r_stage2.iter().map(|c| (*c).into()).collect();
        let r_x_prev: Vec<F> = r_stage1.iter().map(|c| (*c).into()).collect();

        // Precompute matrix row indices for all polynomial indices
        let num_polynomials = bijection.num_polynomials();
        let mut matrix_rows = Vec::with_capacity(num_polynomials);
        for poly_idx in 0..num_polynomials {
            let (constraint_idx, poly_type) = mapping.decode(poly_idx);
            let matrix_row = self
                .constraint_system
                .matrix
                .row_index(poly_type, constraint_idx);
            matrix_rows.push(matrix_row);
        }

        // Create Stage 3 prover
        let mut jagged_prover = JaggedSumcheckProver::new(
            (r_s_final.clone(), r_x_prev.clone()),
            sparse_claim_value,
            dense_poly_f,
            bijection.clone(),
            mapping,
            matrix_rows.clone(),
            transcript,
            self.constraint_system.num_s_vars(),
            self.constraint_system.matrix.num_constraint_vars,
        );

        // Run the jagged sumcheck using BatchedSumcheck
        let (stage3_proof, r_stage3) =
            BatchedSumcheck::prove(vec![&mut jagged_prover], accumulator, transcript);

        // ============ STAGE 3b: Jagged Assist (Batch MLE Verification) ============
        tracing::info_span!("recursion_stage3b_jagged_assist").in_scope(|| {
            tracing::info!("Starting Stage 3b: Jagged Assist batch MLE verification");
        });

        // Convert r_stage3 (dense challenges) to F
        let r_dense: Vec<F> = r_stage3.iter().map(|c| (*c).into()).collect();

        // Compute num_bits for branching program
        let num_constraint_vars = self.constraint_system.matrix.num_constraint_vars;
        let dense_size = <super::bijection::VarCountJaggedBijection as super::bijection::JaggedTransform<Fq>>::dense_size(&bijection);
        let num_dense_vars = dense_size.next_power_of_two().trailing_zeros() as usize;
        let num_bits = std::cmp::max(num_constraint_vars, num_dense_vars);

        // Create Jagged Assist prover - iterates over K polynomials (not rows!)
        let mut assist_prover =
            JaggedAssistProver::<F, T>::new(r_x_prev, r_dense, &bijection, num_bits, transcript);

        // Run Jagged Assist sumcheck
        let (stage3b_sumcheck_proof, _r_assist) =
            BatchedSumcheck::prove(vec![&mut assist_prover], accumulator, transcript);

        // Create the JaggedAssistProof
        let stage3b_proof = JaggedAssistProof {
            claimed_evaluations: assist_prover.claimed_evaluations.clone(),
            sumcheck_proof: stage3b_sumcheck_proof,
        };

        Ok((stage3_proof, stage3b_proof, r_stage3))
    }
}
