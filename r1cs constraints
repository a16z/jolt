R1CS constraints. 
Jolt employs R1CS constraints as a way of enforcing the state transition function for the RiscV virtual machine, as well as serving as sort of the glue between the other components of Jolt.
So starting with the first point, the state transition function, you'll notice that the R1CS constraints, which are declared in constraints.rs, include constraints relating to the program counter or PC, basically constraining that the program counter is updated correctly at each step of execution. 
In order to handle the program counter update, the R1CS constraints also include constraints about jumps and branches as they affect the program counter update. 
And in addition to these, you'll also notice a bunch of other constraints, which effectively sort of glue together the other components of Jolt. 
So you know, Jolt at a high level consists of a couple of Twist and Shout instances, which are themselves just a bunch of sumchecks. 
So there are a couple of ways you might link two sumchecks together. 
One is if they are operating on the exact same polynomial, backed by the same polynomial commitment. 
But another way is like, if there is some more complicated relationship between two polomials, then we can basically represent that and and enforce that relationship using R1CS constraints. 
One example of this is we have an R1CS constraint for if a given instruction is a load instruction (so LB or LW, for example), then the value read from RAM should equal the value written to the rd register for that instruction. 
And the reason we need such a constraint is that conceptually, like the the RAM component of jolt is independent from the register component of jolt. 
They're each their own Twist memory checking instance, basically. 
But you know, we have these sort of dependencies between the two that are extrinsic to Twist. 
And so specifically, this relationship between the Ram Reed values and the RD right values we have to enforce in R1CS constraints. 
And we have several of these such constraints. 
And note that the R1CS constraints in Jolt are somewhat unique in that they are quote unquote uniform, meaning that they apply to every step in the execution trace, every cycle. 
So we can represent all the constraints very minimally. 
In fact, we just write them all down in constraints.rs, with the understanding that they apply to every single cycle, we don't have to repeat them. 
And relatedly, we were able to leverage this uniform structure in Spartan, which is the proof system that we used to prove our R1CS constraints to make the prover vastly more efficient. 
To say a couple of quick things about Spartan is a proof system for RCS developed by authored by Srinath Setty, in 2019, I think.
We have an an implementation of Spartan forked from the Spartan 2 implementation by Srinath. 
We made many optimizations specific to this sort of uniform structure of jolt.

Right, so another concept that arises in the R1CS constraints is that of circuit flags, also known as op flags. 
I think Op flags is the terminology used in the jolt paper, but they're used somewhat interchangeably. 
These are Boolean flags associated with each instruction. 
They are sort of known a priori in the sense that for each instruction in the bytecode, anyone can look at that instruction and determine what the circuit flags should be for that instruction. 
Yeah, there are 17 circuit flags currently, and they include such information as like some examples of the circuit flags are jump, so it's, you know, this circuit flag would be one if the instruction is a jump instruction, such as JAL or JALR.
 Similarly, there's a branch circuit flag for if this instruction is a branch like BEQ or BNE. 
 There's also instructions or circuit flags such as isNoop. We pad our trace to a power of two length using these virtual NOop instructions and so this circuit flag is just saying whether the instruction is one of those. 
 And these circuit flags are used in the R1CS constraints, so the aforementioned constraint about constraining the RAM re value to the right value, if the instruction is a load, that "if load" part is is making use of the load circuit flag, which is, as you might expect, just equals 1 if the given instruction is a load instruction and zero otherwise. 
 So the final thing I wanted to cover about the Spartan part of Jolt is this. So you might notice in the R1CS constraints that we have some inputs called next-something, e.g. nextPC. 
 These represent what the _next_ cycle's PC value is, as opposed to the value for the current cycle. 
 And we need these next inputs because while most of our constraints are just operating on values within a single cycle, a couple of our constraints, namely the ones having to do with the state transition, we'll need to constraint inputs across adjacent cycles in the trace. 
 And the way that we accomplish this is by introducing these virtual nextPC or nextUnexpandedPC polynomials. And these are virtual polomials because well, conceptually, they're, you know, basically just a shifted version of whatever the, you know, PC or unexpandedPC polynomial is. And so in order to prove the claims about these virtual next polynomials, we have this "shift sumcheck", which basically just enforces that, you know, these next polynomials are indeed the expected shifted versions of whatever underlying polomial.