{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww23580\viewh14520\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 One aspect of a Jolt that differentiates it from other ZKVM architectures is how it handles instruction execution, i.e. how the execution of each RISC-V instruction is proven for each cycle. \
Jolt primarily uses a lookup argument for handling instruction execution, more specifically, the Shout lookup argument. \
The Shout instance for instruction execution differs from the other Twist and Shout instances in Jolt in that the size of the effective size of the lookup table being queried is huge. \
The size of the lookup table is effectively 2^64, assuming 32 bit instruction operands, as is the case in RV32IM. \
This is addressed in the Twist and Shout paper in Section 7, Fast Shout prover for Large Structured Memories, which describes precisely this parameter regime, where K, i.e. the size of the lookup table, is very large relative to T the number of lookup queries. \
Our implementation deviates from section 7, which describes using the sparse-dense sumcheck protocol, an algorithm introduced in the appendix G of the Lasso paper. \
However, in implementing the RISC-V lookup tables in Jolt, we found that the sparse-dense sumcheck algorithm did not generalize to support all all RISC-V instructions, and so we developed a new algorithm, which we called prefix-suffix sumcheck. \
And this is described in the appendix of the \'93Proving CPU executions in small space\'94 paper. \
The prefix-suffix algorithm is similar to and inspired by the sparse-dense algorithm. \
Most importantly, it  requires a certain structure in the lookup table being queried. \
The intuition behind the requisite structure of prefix-suffix sumcheck is as follows: \
You can take the lookup query, split it at some index into a prefix and suffix, and evaluate an MLE (or multiple MLEs) on just the prefix bits and then do the same for the suffix bits, then combine these MLE evaluations in such a way that you obtain the queried lookup entry. \
All of the lookup tables used in Jolt for instruction execution are in the `lookup_table` subdirectory, and you'll find that each lookup table implements the `JoltLookupTable` trait, which described how you would materialize the entire lookup table, as well as the MLE corresponding to that lookup table. \
And also the PrefixSuffixDecomposition trait, which describes which MLEs you need to evaluate on the prefix and suffix, and how you would combine those evaluations to obtain the desired lookup table entry. \
\
We also have traits for the prefixes and suffixes themselves. So there is a SparseDensePrefix trait. So under the `prefixes` subdirectory, you'll find every prefix which implements this trait. \
And similarly, there is a SparseDenseSuffix trait. And in the suffixes subdirectory, you'll find all the suffixes implementing that trait. \
The implementation of the prefix-suffix sumcheck algorithm itself is found under read_raf_checking.rs. The sumcheck implementation there is a batched sumcheck of the Shout read-checking and raf evaluation sumchecks for instruction execution. \
Both these sumchecks can be implemented using the same prefix-suffix prover algorithm, and so they are implemented together for efficiency. \
One aspect of the instruction execution instance of shout that is not documented in the Twist and Shout paper is the fact that we need to handle the ability to multiplex between different instructions. \
In the execution trace of any given guest program, you're going to find many different RISC-V instructions, each with their corresponding lookup table. \
Note that there is a one to many relationships between instructions and lookup tables. \
So that means two instructions may share the same lookup table. For example, XOR and XORI use the same lookup table, etc. \
So we have the `InstructionLookupTable` trait, whose method `lookup_table` returns an Option indicating which lookup table, if any, the given instruction uses. \
Conceptually, the instructions that live in jolt-core as opposed to the ones that live in the tracer crate, are the same instructions. \
It's just that the ones in jolt-core are implementing the traits, namely InstructionLookupTable and LookupQuery that are only relevant to the proof system, while the trait implementations in tracer are those needed for tracing. \
\
Returning to the topic of multiplexing between instructions. \
At a high level, the way that we accomplish this is we associate a Boolean flag for each lookup table, indicating whether or not that table was queried at a given cycle. \
So at any given cycle, at most one of those lookup table flags will be set to one, and everything else will be zero. \
And then you can sort of imagine how in the read-checking sumcheck for Shout, instead of having a single Val polynomial corresponding to a single lookup table, we would instead have a sum over all possible lookup tables, and the inner summand would be the flag for that lookup table times the Val polynomial for that lookup table. \
Meaning that for each cycle, exactly one term of that sum will be nonzero corresponding to the table that was accessed at that cycle. \
\
The raf evaluation sum check for instruction execution is on also a bit unique. \
Instead of having a single \'93raf\'94 polynomial, the analogues for instruction execution are the `LeftLookupOperand` and `RightLookupOperand` polynomials, which appear in Jolt\'92s R1CS constraints.\
These loosely correspond to two operands of a RISC-V instruction (most instructions take as input two register values, or one register value and one immediate), but not always. More on this later.\
Let\'92s first consider the more typical case.\
For most lookup tables, the lookup query is formed by we will want to interleave the bits of the left and right operand. \
For example, consider the XOR instruction. \
Intuitively, if you have XOR of x and y, you could look at just the upper bits of x, XOR them with the upper bits of y and do the same with the lower bits of x and the lower bits of y, and then concatenate the result of the two smaller XORs. \
That's sort of the intuition behind the prefix-suffix implementation for the XOR lookup table. \
But what we really need is a single lookup query constructed from X and Y. And so the natural thing to sort of do here is interleeave the bits of X and y. \
That way, when we split the lookup query at some index, the prefix will contain the upper m bits of X, as well as the upper m bits of Y. And similarly, the suffix will contain the lower n bits of x and lower n bits of y. \
And then we would just compute the XOR MLE on the prefix and suffix as basically as you would expect, with the knowledge that the bits of X and Y are interleaved. \
So for lookup tables like XOR, the ra polynomial will capture this bit-interleaved query format, and instead of a single raf-evaluation sumcheck we have two sumchecks (one for the LeftLookupOperand and one for RightLookupOperand), which concatenate the even-index and odd-index \'93bits\'94 of ra, respectively. \
\
And it turns out most of the RISC-V instruction set, we can do this interleaving of the operand bits. \
However, there are some instructions that are different, specifically a lot of the arithmetic operations: add, subtract, multiply, for example. \
The way that we handle their execution in Jolt is we actually perform the arithmetic operation in the field. \
So you'll see addition, subtraction, multiplication being handled in the R1CS constraints. \
We actually compute the result of that arithmetic operation, and that becomes part of the witness. \
And then we still do a lookup for the resulting values, but all that the lookup is doing in those cases is truncating to the relevant bit length. \
So 32 bits in the case of the RV32IM. \
This truncation lookup table is also known as a range check lookup table. \
Now, this gets a little tricky with the raf-evaluation sumcheck, because now the lookup query is constructed from just a single value, there\'92s no interleaving of bits. \
We now have RightLookupOperand representing the sum or the product, for example, of two other values, and LeftLookupOperand is set to 0.\
So this case is actually more similar to the raf-evaluation as it's described in the Twist and Shout paper, where RightLookupOperand is basically raf.\
\
In order to handle the two raf-evaluation scenarios, we employ the sane flag technique used to multiplex between different instructions in the read-checking sumcheck \'96\'96\'a0we have a flag indicating which of the two cases we\'92re in for a given instruction. \
\
In practice this whole raf-evaluation thing is batched together with the read-checking sum check. \
Fortunately, all of these sumchecks share a prefix-suffix structure and so tehy can be proven using the same prover algorithm. \
\
In addition to the read-checking and raf-evaluation sumchecks, we also have a Booleanity sumcheck and a Hamming weight sumcheck to check that the ra polynomials are indeed one-hot. These prover algorithms follow the description in the Twist and Shout paper closely, with no deviations of note.}